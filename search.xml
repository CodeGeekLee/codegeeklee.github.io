<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>「Java8系列」神奇的函数式接口</title>
      <link href="/2019/11/03/java8-xi-lie-shen-qi-de-han-shu-shi-jie-kou/"/>
      <url>/2019/11/03/java8-xi-lie-shen-qi-de-han-shu-shi-jie-kou/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在上一篇Lambda的讲解中我们就提到过函数式接口，比如：Consumer<code>&lt;String&gt;</code> consumer = (s) -&gt; System.out.println(s);其中Consumer就是一个函数式接口。这里是通过Lambda表达式创建了一个函数式接口的对象。如果不知道什么是Lambda，请看《<a href="https://juejin.im/post/5d2d15825188253d7201d297" target="_blank" rel="noopener">神秘的Lambda</a>》。</p><h4 id="函数式接口是什么？"><a href="#函数式接口是什么？" class="headerlink" title="函数式接口是什么？"></a>函数式接口是什么？</h4><p>有且只有一个抽象方法的接口被称为函数式接口，函数式接口适用于函数式编程的场景，Lambda就是Java中函数式编程的体现，可以使用Lambda表达式创建一个函数式接口的对象，一定要确保接口中有且只有一个抽象方法，这样Lambda才能顺利的进行推导。</p><h4 id="FunctionalInterface注解"><a href="#FunctionalInterface注解" class="headerlink" title="@FunctionalInterface注解"></a>@FunctionalInterface注解</h4><p>与@Override 注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解：@FunctionalInterface 。该注解可用于一个接口的定义上,一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。但是这个注解不是必须的，只要符合函数式接口的定义，那么这个接口就是函数式接口。</p><h4 id="static方法和default方法"><a href="#static方法和default方法" class="headerlink" title="static方法和default方法"></a>static方法和default方法</h4><p>实在不知道该在哪介绍这两个方法了，所以就穿插在这里了。</p><h5 id="static方法："><a href="#static方法：" class="headerlink" title="static方法："></a>static方法：</h5><p>java8中为接口新增了一项功能，定义一个或者多个静态方法。用法和普通的static方法一样,例如：</p><pre><code>public interface Interface {    /**     * 静态方法     */    static void staticMethod() {        System.out.println(&quot;static method&quot;);    }}</code></pre><p><code>注意:实现接口的类或者子接口不会继承接口中的静态方法。</code></p><h5 id="default方法："><a href="#default方法：" class="headerlink" title="default方法："></a>default方法：</h5><p>java8在接口中新增default方法，是为了在现有的类库中中新增功能而不影响他们的实现类，试想一下，如果不增加默认实现的话，接口的所有实现类都要实现一遍这个方法，这会出现兼容性问题，如果定义了默认实现的话，那么实现类直接调用就可以了，并不需要实现这个方法。default方法怎么定义？</p><pre><code>public interface Interface {    /**     * default方法     */    default void print() {        System.out.println(&quot;hello default&quot;);    }}</code></pre><p><code>注意：如果接口中的默认方法不能满足某个实现类需要，那么实现类可以覆盖默认方法。不用加default关键字，</code>例如：</p><pre><code>public class InterfaceImpl implements Interface {    @Override    public  void print() {        System.out.println(&quot;hello default 2&quot;);    }}</code></pre><p>在函数式接口的定义中是只允许有一个抽象方法，但是可以有多个static方法和default方法。</p><h4 id="自定义函数式接口"><a href="#自定义函数式接口" class="headerlink" title="自定义函数式接口"></a>自定义函数式接口</h4><p>按照下面的格式定义，你也能写出函数式接口：</p><pre><code> @FunctionalInterface 修饰符 interface 接口名称 {    返回值类型 方法名称(可选参数信息);    // 其他非抽象方法内容 }</code></pre><p>虽然@FunctionalInterface注解不是必须的，但是自定义函数式接口最好还是都加上，一是养成良好的编程习惯，二是防止他人修改，一看到这个注解就知道是函数式接口，避免他人往接口内添加抽象方法造成不必要的麻烦。</p><pre><code>@FunctionalInterfacepublic interface MyFunction {    void print(String s);}</code></pre><p>看上图是我自定义的一个函数式接口，那么这个接口的作用是什么呢？就是输出一串字符串，属于消费型接口，是模仿Consumer接口写的，只不过这个没有使用泛型，而是将参数具体类型化了，不知道Consumer没关系，下面会介绍到，其实java8中提供了很多常用的函数式接口，Consumer就是其中之一，一般情况下都不需要自己定义，直接使用就好了。那么怎么使用这个自定义的函数式接口呢？我们可以用函数式接口作为参数，调用时传递Lambda表达式。如果一个方法的参数是Lambda，那么这个参数的类型一定是函数式接口。例如：</p><pre><code>public class MyFunctionTest {    public static void main(String[] args) {        String text = &quot;试试自定义函数好使不&quot;;        printString(text, System.out::print);    }    private static void printString(String text, MyFunction myFunction) {        myFunction.print(text);    }}</code></pre><p>执行以后就会输出“试试自定义函数好使不”这句话，如果某天需求变了，我不想输出这句话了，想输出别的，那么直接替换text就好了。函数式编程是没有副作用的，最大的好处就是函数的内部是无状态的，既输入确定输出就确定。函数式编程还有更多好玩的套路，这就需要靠大家自己探索了。😝</p><h4 id="常用函数式接口"><a href="#常用函数式接口" class="headerlink" title="常用函数式接口"></a>常用函数式接口</h4><h5 id="Consumer-lt-T-gt-：消费型接口"><a href="#Consumer-lt-T-gt-：消费型接口" class="headerlink" title="Consumer&lt;T&gt;：消费型接口"></a>Consumer<code>&lt;T&gt;</code>：消费型接口</h5><p><strong>抽象方法：</strong>  void accept(T t)，接收一个参数进行消费，但无需返回结果。</p><p><strong>使用方式：</strong></p><pre><code>  Consumer consumer = System.out::println;  consumer.accept(&quot;hello function&quot;);</code></pre><p><strong>默认方法：</strong> andThen(Consumer&lt;? super T&gt; after)，先消费然后在消费，先执行调用andThen接口的accept方法，然后在执行andThen方法参数after中的accept方法。</p><p><strong>使用方式：</strong>        </p><pre><code>  Consumer&lt;String&gt; consumer1 = s -&gt; System.out.print(&quot;车名：&quot;+s.split(&quot;,&quot;)[0]);  Consumer&lt;String&gt; consumer2 = s -&gt; System.out.println(&quot;--&gt;颜色：&quot;+s.split(&quot;,&quot;)[1]);  String[] strings = {&quot;保时捷,白色&quot;, &quot;法拉利,红色&quot;};  for (String string : strings) {     consumer1.andThen(consumer2).accept(string);  }</code></pre><p><strong>输出：</strong><br>车名：保时捷–&gt;颜色：白色<br>车名：法拉利–&gt;颜色：红色</p><h5 id="Supplier-lt-T-gt-供给型接口"><a href="#Supplier-lt-T-gt-供给型接口" class="headerlink" title="Supplier&lt;T&gt;: 供给型接口"></a>Supplier<code>&lt;T&gt;</code>: 供给型接口</h5><p><strong>抽象方法</strong>：T get()，无参数，有返回值。</p><p><strong>使用方式：</strong></p><pre><code> Supplier&lt;String&gt; supplier = () -&gt; &quot;我要变的很有钱&quot;; System.out.println(supplier.get());</code></pre><p>最后输出就是“我要变得很有钱”，这类接口适合提供数据的场景。</p><h5 id="Function-lt-T-R-gt-函数型接口"><a href="#Function-lt-T-R-gt-函数型接口" class="headerlink" title="Function&lt;T,R&gt;: 函数型接口"></a>Function<code>&lt;T,R&gt;</code>: 函数型接口</h5><p><strong>抽象方法：</strong> R apply(T t)，传入一个参数，返回想要的结果。</p><p><strong>使用方式：</strong></p><pre><code> Function&lt;Integer, Integer&gt; function1 = e -&gt; e * 6; System.out.println(function1.apply(2));</code></pre><p>很简单的一个乘法例子，显然最后输出是12。</p><p><strong>默认方法：</strong></p><ul><li>compose(Function&lt;? super V, ? extends T&gt; before)，先执行compose方法参数before中的apply方法，然后将执行结果传递给调用compose函数中的apply方法在执行。</li></ul><p><strong>使用方式：</strong></p><pre><code> Function&lt;Integer, Integer&gt; function1 = e -&gt; e * 2; Function&lt;Integer, Integer&gt; function2 = e -&gt; e * e; Integer apply2 = function1.compose(function2).apply(3); System.out.println(apply2);</code></pre><p>还是举一个乘法的例子，compose方法执行流程是先执行function2的表达式也就是3<em>3=9，然后在将执行结果传给function1的表达式也就是9</em>2=18，所以最终的结果是18。</p><ul><li>andThen(Function&lt;? super R, ? extends V&gt; after)，先执行调用andThen函数的apply方法，然后在将执行结果传递给andThen方法after参数中的apply方法在执行。它和compose方法整好是相反的执行顺序。</li></ul><p><strong>使用方式：</strong></p><pre><code> Function&lt;Integer, Integer&gt; function1 = e -&gt; e * 2; Function&lt;Integer, Integer&gt; function2 = e -&gt; e * e; Integer apply3 = function1.andThen(function2).apply(3); System.out.println(apply3);</code></pre><p>这里我们和compose方法使用一个例子，所以是一模一样的例子，由于方法的不同，执行顺序也就不相同，那么结果是大大不同的。andThen方法是先执行function1表达式，也就是3<em>2=6，然后在执行function2表达式也就是6</em>6=36。结果就是36。<br><strong>静态方法：</strong>identity()，获取一个输入参数和返回结果相同的Function实例。</p><p><strong>使用方式：</strong> </p><pre><code> Function&lt;Integer, Integer&gt; identity = Function.identity(); Integer apply = identity.apply(3); System.out.println(apply);</code></pre><p>平常没有遇到过使用这个方法的场景，总之这个方法的作用就是输入什么返回结果就是什么。</p><h5 id="Predicate-lt-T-gt-：-断言型接口"><a href="#Predicate-lt-T-gt-：-断言型接口" class="headerlink" title="Predicate&lt;T&gt; ： 断言型接口"></a>Predicate<code>&lt;T&gt;</code> ： 断言型接口</h5><p><strong>抽象方法：</strong> boolean test(T t),传入一个参数，返回一个布尔值。</p><p><strong>使用方式：</strong></p><pre><code> Predicate&lt;Integer&gt; predicate = t -&gt; t &gt; 0; boolean test = predicate.test(1); System.out.println(test);</code></pre><p>当predicate函数调用test方法的时候，就会执行拿test方法的参数进行t -&gt; t &gt; 0的条件判断，1肯定是大于0的，最终结果为true。</p><p><strong>默认方法：</strong></p><ul><li>and(Predicate&lt;? super T&gt; other)，相当于逻辑运算符中的&amp;&amp;，当两个Predicate函数的返回结果都为true时才返回true。</li></ul><p><strong>使用方式：</strong></p><pre><code> Predicate&lt;String&gt; predicate1 = s -&gt; s.length() &gt; 0; Predicate&lt;String&gt; predicate2 = Objects::nonNull; boolean test = predicate1.and(predicate2).test(&quot;&amp;&amp;测试&quot;); System.out.println(test);</code></pre><ul><li>or(Predicate&lt;? super T&gt; other) ,相当于逻辑运算符中的||，当两个Predicate函数的返回结果有一个为true则返回true，否则返回false。</li></ul><p><strong>使用方式：</strong></p><pre><code> Predicate&lt;String&gt; predicate1 = s -&gt; false; Predicate&lt;String&gt; predicate2 = Objects::nonNull; boolean test = predicate1.and(predicate2).test(&quot;||测试&quot;); System.out.println(test);</code></pre><ul><li>negate()，这个方法的意思就是取反。</li></ul><p><strong>使用方式：</strong></p><pre><code> Predicate&lt;String&gt; predicate = s -&gt; s.length() &gt; 0; boolean result = predicate.negate().test(&quot;取反&quot;); System.out.println(result);</code></pre><p>很明显正常执行test方法的话应该为true，但是调用negate方法后就返回为false了。<br><strong>静态方法：</strong>isEqual(Object targetRef)，对当前操作进行”=”操作,即取等操作,可以理解为 A == B。</p><p><strong>使用方式:</strong></p><pre><code> boolean test1 = Predicate.isEqual(&quot;test&quot;).test(&quot;test&quot;); boolean test2 = Predicate.isEqual(&quot;test&quot;).test(&quot;equal&quot;); System.out.println(test1);   //true System.out.println(test2);   //false</code></pre><h4 id="其他函数式接口"><a href="#其他函数式接口" class="headerlink" title="其他函数式接口"></a>其他函数式接口</h4><h5 id="Bi类型接口"><a href="#Bi类型接口" class="headerlink" title="Bi类型接口"></a>Bi类型接口</h5><p>BiConsumer、BiFunction、BiPrediate 是 Consumer、Function、Predicate 的扩展，可以传入多个参数，没有 BiSupplier 是因为 Supplier 没有入参。</p><h5 id="操作基本数据类型的接口"><a href="#操作基本数据类型的接口" class="headerlink" title="操作基本数据类型的接口"></a>操作基本数据类型的接口</h5><p>IntConsumer、IntFunction、IntPredicate、IntSupplier、LongConsumer、LongFunction、LongPredicate、LongSupplier、DoubleConsumer、DoubleFunction、DoublePredicate、DoubleSupplier。<br>其实常用的函数式接口就那四大接口Consumer、Function、Prediate、Supplier，其他的函数式接口就不一一列举了，有兴趣的可以去java.util.function这个包下详细的看。</p><blockquote><p>感谢大家的观看，希望多多关注哦。 如有错误，烦请指正。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Go学习笔记」2.Go语言由什么组成？</title>
      <link href="/2019/11/02/go-xue-xi-bi-ji-2-go-yu-yan-you-shi-me-zu-cheng/"/>
      <url>/2019/11/02/go-xue-xi-bi-ji-2-go-yu-yan-you-shi-me-zu-cheng/</url>
      
        <content type="html"><![CDATA[<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>Go语言标识符是用于标识变量、函数或任何用户自定义项目的名称（程序实体），这个标识符就类似java中的数据类型（基本数据类型、引用数据类型）。标识符有两种类别，一种是用户自定义的标识符，它作为程序的实体存在。另一种标识符成为预定义标识符，是Go语言源代码中声明的。例如：</p><ol><li><p>数据类型</p><p>bool（true和false）、byte、uint、uint8、uint16、uint32、uint64、int、int8、int16、int32、int64、float32、float64、string、uintptr。</p></li><li><p>内建函数名</p><p>append、cap、close、complex、copy、delete、imag、len、make、new、panic、print、println、real、recover。</p></li><li><p>其他标识符</p><p>iota、nil、_ 。</p><p>最后一个_叫做空标识符，一般用在变量声明与包的导入中，类似Java中的null。</p></li></ol><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>Go语言作为一门静态编译型语言，它的关键字一共有25个，相比他语言显得非常少，java关键字就有50个，不过感觉Go语言的关键字少的原因也是因为它把数据类型和关键字分开了，数据类型叫做标识符了，下面是Go语言的25个关键字</p><ol><li><p>包导入与声明</p><p>import、package。</p></li><li><p>程序实体声明与定义</p><p>var、type、func、interface、map、struct、chan、const。</p></li><li><p>流程控制</p><p>if、continue、for、return、go、case、goto、switch、select、clse、break、default、defer、fallthrough、range。</p></li></ol><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>字面量就是表示值得一种标记法，在Go语言中，字面量的含义要更广一些，首先，它用于表示基础数据类型的各种字面量，其次用于标识用户构造的自定义复合数据类型的字面量，最后它还用于标识复合数据类型的值的复合字面量，简单来说它会被用来构造Struct（结构体）、Array（数组）、Slice（切片）和Map（字典）的值。</p><p>例如：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">const</span> b <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">10</span> <span class="token comment" spellcheck="true">//b为常量，10为字面量</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h3><p>分隔符用来分隔Go语言中的元素，例如：</p><pre class="line-numbers language-go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello ，World"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>分隔符包括括号、中括号、大括号、小数点、逗号、分号、冒号、省略号。Go语言不需要像java那样每行代码都要以分号（;）结尾。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>运算符是用来执行运算或逻辑操作的符号，Go语言中的运算符如下图所示</p><ol><li>运算符<br><img src="https://user-gold-cdn.xitu.io/2019/10/19/16de344d04dffd76?w=1460&h=1002&f=png&s=1362101" alt><br><img src="https://user-gold-cdn.xitu.io/2019/10/19/16de344fb5ae925c?w=1460&h=268&f=png&s=245596" alt></li><li>运算符优先级：<br><img src="https://user-gold-cdn.xitu.io/2019/10/19/16de34450aea1678?w=998&h=381&f=png&s=23293" alt><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3>Go语言中的注释有多种写法和Java差不多。<pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 单行注释</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">/*这是一条Go注释*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">/*这是一段Go注释*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>感谢大家的观看，希望多多关注哦。 如有错误，烦请指正。</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUnit4教程+实践</title>
      <link href="/2019/11/01/junit4-jiao-cheng-shi-jian/"/>
      <url>/2019/11/01/junit4-jiao-cheng-shi-jian/</url>
      
        <content type="html"><![CDATA[<p><img src="junit.jpg" alt></p><h4 id="一、什么是JUnit？"><a href="#一、什么是JUnit？" class="headerlink" title="一、什么是JUnit？"></a>一、什么是JUnit？</h4><p>JUnit是Java编程语言的单元测试框架，用于编写和可重复运行的自动化测试。</p><h4 id="二、JUnit特点："><a href="#二、JUnit特点：" class="headerlink" title="二、JUnit特点："></a>二、JUnit特点：</h4><ul><li>JUnit 是一个开放的资源框架，用于编写和运行测试。 </li><li>提供注解来识别测试方法。</li><li>提供断言来测试预期结果。 </li><li>JUnit 测试允许你编写代码更快，并能提高质量。</li><li>JUnit 优雅简洁。没那么复杂，花费时间较少。 </li><li>JUnit测试可以自动运行并且检查自身结果并提供即时反馈。所以也没有必要人工梳理测试结果的报告。 </li><li>JUnit测试可以被组织为测试套件，包含测试用例，甚至其他的测试套件。 </li><li>JUnit在一个条中显示进度。如果运行良好则是绿色；如果运行失败，则变成红色。</li></ul><h4 id="三、JUnit注解"><a href="#三、JUnit注解" class="headerlink" title="三、JUnit注解"></a>三、JUnit注解</h4><table><thead><tr><th>注解</th><th>描述</th></tr></thead><tbody><tr><td>@Test</td><td>测试注解，标记一个方法可以作为一个测试用例 。</td></tr><tr><td>@Before</td><td>Before注解表示，该方法必须在类中的每个测试之前执行,以便执行某些必要的先决条件。</td></tr><tr><td>@BeforeClass</td><td>BeforeClass注解指出这是附着在静态方法必须执行一次并在类的所有测试之前，这种情况一般用于测试计算、共享配制方法(如数据库连接)。</td></tr><tr><td>@After</td><td>After注释表示，该方法在每项测试后执行（如执行每一个测试后重置某些变量，删除临时变量等）。</td></tr><tr><td>@AfterClass</td><td>当需要执行所有测试在JUnit测试用例类后执行，AlterClass注解可以使用以清理一些资源（如数据库连接），注意：方法必须为静态方法。</td></tr><tr><td>@Ignore</td><td>当想暂时禁用特定的测试执行可以使用这个注解，每个被注解为@Ignore的方法将不再执行</td></tr><tr><td>@Runwith</td><td>@Runwith就是放在测试类名之前，用来确定这个类怎么运行的。也可以不标注，会使用默认运行器。</td></tr><tr><td>@Parameters</td><td>用于使用参数化功能。</td></tr><tr><td>@SuiteClasses</td><td>用于套件测试</td></tr></tbody></table><h4 id="四、JUnit断言"><a href="#四、JUnit断言" class="headerlink" title="四、JUnit断言"></a>四、JUnit断言</h4><table><thead><tr><th>断言</th><th>描述</th></tr></thead><tbody><tr><td>void assertEquals([String message],expected value,actual value)</td><td>断言两个值相等。值类型可能是int，short，long，byte，char，Object，第一个参数是一个可选字符串消息</td></tr><tr><td>void assertTrue([String message],boolean condition)</td><td>断言一个条件为真</td></tr><tr><td>void assertFalse([String message],boolean condition)</td><td>断言一个条件为假</td></tr><tr><td>void assertNotNull([String message],java.lang.Object object)</td><td>断言一个对象不为空（null）</td></tr><tr><td>void assertNull([String message],java.lang.Object object)</td><td>断言一个对象为空（null）</td></tr><tr><td>void assertSame([String message],java.lang.Object expected,java.lang.Object actual)</td><td>断言两个对象引用相同的对象</td></tr><tr><td>void assertNotSame([String message],java.lang.Object unexpected,java.lang.Object actual)</td><td>断言两个对象不是引用同一个对象</td></tr><tr><td>void assertArrayEquals([String message],expectedArray,resultArray)</td><td>断言预期数组和结果数组相等，数组类型可能是int，short，long，byte，char，Object</td></tr></tbody></table><p>让我们看下使用断言的例子。<br>AssertionTest.java</p><pre><code>public class AssertionTest {    @Test    public void test() {        String obj1 = &quot;junit&quot;;        String obj2 = &quot;junit&quot;;        String obj3 = &quot;test&quot;;        String obj4 = &quot;test&quot;;        String obj5 = null;        int var1 = 1;        int var2 = 2;        int[] array1 = {1, 2, 3};        int[] array2 = {1, 2, 3};        Assert.assertEquals(obj1, obj2);        Assert.assertSame(obj3, obj4);        Assert.assertNotSame(obj2, obj4);        Assert.assertNotNull(obj1);        Assert.assertNull(obj5);        Assert.assertTrue(var1 &lt; var2);        Assert.assertFalse(var1 &gt; var2);        Assert.assertArrayEquals(array1, array2);    }}</code></pre><p>在以上类中我们可以看到，这些断言方法是可以工作的。  </p><ul><li>assertEquals() 如果比较的两个对象是相等的，此方法将正常返回；否则失败显示在JUnit的窗口测试将中止。  </li><li>assertSame() 和 assertNotSame() 方法测试两个对象引用指向完全相同的对象。  </li><li>assertNull() 和 assertNotNull() 方法测试一个变量是否为空或不为空(null)。  </li><li>assertTrue() 和 assertFalse() 方法测试if条件或变量是true还是false。  </li><li>assertArrayEquals() 将比较两个数组，如果它们相等，则该方法将继续进行不会发出错误。否则失败将显示在JUnit窗口和中止测试。</li></ul><h4 id="五、JUnit执行过程"><a href="#五、JUnit执行过程" class="headerlink" title="五、JUnit执行过程"></a>五、JUnit执行过程</h4><p>JuntiTest.java</p><pre><code>public class JunitTest {    @BeforeClass    public static void beforeClass() {        System.out.println(&quot;in before class&quot;);    }    @AfterClass    public static void afterClass() {        System.out.println(&quot;in after class&quot;);    }    @Before    public void before() {        System.out.println(&quot;in before&quot;);    }    @After    public void after() {        System.out.println(&quot;in after&quot;);    }    @Test    public void testCase1() {        System.out.println(&quot;in test case 1&quot;);    }    @Test    public void testCase2() {        System.out.println(&quot;in test case 2&quot;);    }}</code></pre><p>通过idea执行整个测试类后，执行结果：</p><pre><code>in before classin beforein test case 1in afterin beforein test case 2in afterin after class</code></pre><h4 id="六、忽略测试"><a href="#六、忽略测试" class="headerlink" title="六、忽略测试"></a>六、忽略测试</h4><ul><li>一个带有@Ignore注解的测试方法不会被执行</li><li>如果一个测试类带有@Ignore注解，则它的测试方法将不会被执行</li></ul><p>我们把刚才测试类中的testCase2()方法标记为@Ignore,</p><pre><code>    @Ignore    @Test    public void testCase2() {        System.out.println(&quot;in test case 2&quot;);    }</code></pre><p>然后在执行测试类的时候就会忽视这个方法，结果为：</p><pre><code>in before classin beforein test case 1in afterTest ignored.in after class</code></pre><h4 id="七、时间测试"><a href="#七、时间测试" class="headerlink" title="七、时间测试"></a>七、时间测试</h4><p>JUnit提供了一个暂停的方便选项，如果一个测试用例比起指定的毫秒数花费了更多的时间，那么JUnit将自动将它标记为失败，timeout参数和@Test注解一起使用，例如@Test(timeout=1000)。<br>继续使用刚才的例子，现在将testCase1的执行时间延长到5000毫秒，并加上时间参数,设置超时为1000毫秒，然后执行测试类</p><pre><code>    @Test(timeout = 1000)    public void testCase1() throws InterruptedException {        TimeUnit.SECONDS.sleep(5000);        System.out.println(&quot;in test case 1&quot;);    }</code></pre><p>testCase1被标记为失败，并且抛出异常，执行结果：</p><pre><code>in before classin beforein afterorg.junit.runners.model.TestTimedOutException: test timed out after 1000 milliseconds    at java.lang.Thread.sleep(Native Method)    at java.lang.Thread.sleep(Thread.java:340)    at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)    at com.lxs.JUnit.JunitTest.testCase1(JunitTest.java:35)    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)    at java.lang.reflect.Method.invoke(Method.java:498)    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)    at org.junit.internal.runners.statements.FailOnTimeout$CallableStatement.call(FailOnTimeout.java:298)    at org.junit.internal.runners.statements.FailOnTimeout$CallableStatement.call(FailOnTimeout.java:292)    at java.util.concurrent.FutureTask.run(FutureTask.java:266)    at java.lang.Thread.run(Thread.java:748)in beforein test case 2in afterin after class</code></pre><h4 id="八、异常测试"><a href="#八、异常测试" class="headerlink" title="八、异常测试"></a>八、异常测试</h4><p>Junit 用代码处理提供了一个追踪异常的选项。你可以测试代码是否它抛出了想要得到的异常。expected 参数和 @Test 注释一起使用。现在让我们看看 @Test(expected)。新建测试方法testCase3()。</p><pre><code>    @Test(expected = ArithmeticException.class)    public void testCase3() {        System.out.println(&quot;in test case 3&quot;);        int a = 0;        int b = 1 / a;    }</code></pre><p>单独执行testCase3()方法，由于得到了一个预期异常，所以测试通过，结果为</p><pre><code>in before classin beforein test case 3in afterin after class</code></pre><p>如果没有得到预期异常：</p><pre><code>in before classin beforein test case 3in afterjava.lang.AssertionError: Expected exception: java.lang.ArithmeticExceptionin after class</code></pre><h4 id="九、参数化测试"><a href="#九、参数化测试" class="headerlink" title="九、参数化测试"></a>九、参数化测试</h4><p>Junit 4 引入了一个新的功能参数化测试。参数化测试允许开发人员使用不同的值反复运行同     一个测试。你将遵循 5 个步骤来创建参数化测试：</p><p> -为准备使用参数化测试的测试类指定特殊的运行器 org.junit.runners.Parameterized。</p><ul><li>为测试类声明几个变量，分别用于存放期望值和测试所用数据。</li><li>为测试类声明一个带有参数的公共构造函数，并在其中为第二个环节中声明的几个变量赋值。</li><li>为测试类声明一个使用注解 org.junit.runners.Parameterized.Parameters 修饰的，返回值为 java.util.Collection 的公共静态方法，并在此方法中初始化所有需要测试的参数对。</li><li>编写测试方法，使用定义的变量作为参数进行测试。</li></ul><h6 id="什么是-RunWith"><a href="#什么是-RunWith" class="headerlink" title="什么是@RunWith?"></a>什么是@RunWith?</h6><p> 首先要分清几个概念：测试方法、测试类、测试集、测试运行器。</p><ul><li>其中测试方法就是用@Test注解的一些函数。</li><li>测试类是包含一个或多个测试方法的一个**Test.java文件，</li><li>测试集是一个suite，可能包含多个测试类。</li><li>测试运行器则决定了用什么方式偏好去运行这些测试集/类/方法。</li></ul><p>而@Runwith就是放在测试类名之前，用来确定这个类怎么运行的。也可以不标注，会使用默认运行器。常见的运行器有：</p><ul><li>@RunWith(Parameterized.class) 参数化运行器，配合@Parameters使用JUnit的参数化功能</li><li>@RunWith(Suite.class)<br>@SuiteClasses({ATest.class,BTest.class,CTest.class})<br>测试集运行器配合使用测试集功能</li><li>@RunWith(JUnit4.class)，    junit4的默认运行器</li><li>@RunWith(JUnit38ClassRunner.class)，用于兼容junit3.8的运行器</li><li>一些其它运行器具备更多功能。例如@RunWith(SpringJUnit4ClassRunner.class)集成了spring的一些功能</li></ul><p>PrimeNumberCheckerTest.java</p><pre><code>/** * 步骤一: 指定定参数运行器 */@RunWith(Parameterized.class)public class PrimeNumberCheckerTest {    /**     * 步骤二：声明变量     */    private Integer inputNumber;    private Boolean expectedResult;    private PrimeNumberChecker primeNumberChecker;    /**     * 步骤三：为测试类声明一个带有参数的公共构造函数，为变量赋值     */    public PrimeNumberCheckerTest(Integer inputNumber,                                  Boolean expectedResult) {        this.inputNumber = inputNumber;        this.expectedResult = expectedResult;    }    /**     * 步骤四：为测试类声明一个使用注解 org.junit.runners.Parameterized.Parameters 修饰的，返回值为     * java.util.Collection 的公共静态方法，并在此方法中初始化所有需要测试的参数对     *   1）该方法必须由Parameters注解修饰           2）该方法必须为public static的           3）该方法必须返回Collection类型           4）该方法的名字不做要求           5）该方法没有参数      */    @Parameterized.Parameters    public static Collection primeNumbers() {        return Arrays.asList(new Object[][]{                {2, true},                {6, false},                {19, true},                {22, false},                {23, true}        });    }    @Before    public void initialize() {        primeNumberChecker = new PrimeNumberChecker();    }    /**     * 步骤五：编写测试方法，使用自定义变量进行测试     */    @Test    public void testPrimeNumberChecker() {        System.out.println(&quot;Parameterized Number is : &quot; + inputNumber);        Assert.assertEquals(expectedResult,                primeNumberChecker.validate(inputNumber));    }}</code></pre><p>PrimeNumberChecker.java</p><pre><code>public class PrimeNumberChecker {    public Boolean validate(final Integer parimeNumber) {        for (int i = 2; i &lt; (parimeNumber / 2); i++) {            if (parimeNumber % i == 0) {                return false;            }        }        return true;    }}</code></pre><p>JUnit会按照设置的参数多次执行，执行结果：</p><pre><code>Parameterized Number is : 2Parameterized Number is : 6Parameterized Number is : 19Parameterized Number is : 22Parameterized Number is : 23</code></pre><h4 id="十、套件测试"><a href="#十、套件测试" class="headerlink" title="十、套件测试"></a>十、套件测试</h4><p>“套件测试”是指捆绑了几个单元测试用例并运行起来。在JUnit中，@RunWith 和 @Suite 这两个注解是用来运行套件测试。先来创建几个测试类</p><pre><code>public class JunitTest1 {    @Test    public void printMessage(){        System.out.println(&quot;in JunitTest1&quot;);    }}</code></pre><pre><code>public class JunitTest2 {    @Test    public void printMessage(){        System.out.println(&quot;in JunitTest2&quot;);    }}</code></pre><pre><code>@RunWith(Suite.class)@Suite.SuiteClasses({        /**         * 此处类的配置顺序会影响执行顺序         */        JunitTest1.class,        JunitTest2.class})public class JunitSuite {}</code></pre><p>执行JunitSuite测试类，执行结果：</p><pre><code>in JunitTest1in JunitTest2</code></pre>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUnit4 </tag>
            
            <tag> 单元测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Java8系列」神秘的Lambda</title>
      <link href="/2019/10/31/java8-xi-lie-shen-mi-de-lambda/"/>
      <url>/2019/10/31/java8-xi-lie-shen-mi-de-lambda/</url>
      
        <content type="html"><![CDATA[<h4 id="接触背景"><a href="#接触背景" class="headerlink" title="接触背景"></a>接触背景</h4><p>第一次接触lambda表达式时，感觉这个东西挺神奇的（高逼格），一个（）加-&gt;就能传递一段代码，当时公司项目中接手同事的代码，自己也对java8的特性不了解，看的也是一头雾水，之后就赶快看了下《java8实战》这本书，决定写一个java8特性系列的博客，既加深自己的印象，还能跟大家分享一下，希望大家多多指教😄。</p><h4 id="什么是Lambda？"><a href="#什么是Lambda？" class="headerlink" title="什么是Lambda？"></a>什么是Lambda？</h4><p>Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码(将代码像参数一样进行传递，称为行为参数化)。Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中），要做到这一点就需要了解，什么是函数式接口，这里先不做介绍，等下一篇在讲解。</p><p>首先先看一下lambda长什么样？<br>正常写法：</p><pre><code>new Thread(new Runnable() {    @Override    public void run() {       System.out.println(&quot;hello lambda&quot;);    }}).start();</code></pre><p>lambda写法：</p><pre><code>new Thread(    () -&gt; System.out.println(&quot;hello lambda&quot;)).start();</code></pre><p>怎么样？是不是感觉很简洁，没错，这就是lambda的魅力，他可以让你写出来的代码更简单、更灵活。</p><h4 id="Lambda怎么写？"><a href="#Lambda怎么写？" class="headerlink" title="Lambda怎么写？"></a>Lambda怎么写？</h4><p><img src="https://user-gold-cdn.xitu.io/2019/7/16/16bf81c30ea9b895?w=798&h=434&f=png&s=59257" alt><br>大家看一些上面的这个图，这就是lambda的语法，一个lambda分为三部分：参数列表、操作符、lambda体。以下是lambda表达式的重要特征：</p><ul><li><code>可选类型声明：</code><br>不需要声明参数类型，编译器可以统一识别参数值。也就说(s) -&gt; System.out.println(s)和<br>(String s) -&gt; System.out.println(s)是一样的编译器会进行类型推断所以不需要添加参数类型。</li><li><code>可选的参数圆括号：</code><br>一个参数无需定义圆括号，但多个参数需要定义圆括号。例如：<ol><li>s -&gt; System.out.println(s)  一个参数不需要添加圆括号。</li><li>(x, y) -&gt; Integer.compare(y, x) 两个参数添加了圆括号，否则编译器报错。</li></ol></li><li><code>可选的大括号：</code><br>如果主体包含了一个语句，就不需要使用大括号。<ol><li>s -&gt; System.out.println(s) , 不需要大括号.</li><li>(s) -&gt; {<pre><code>     if (s.equals(&quot;s&quot;)){        System.out.println(s);     }</code></pre>   };    需要大括号</li></ol></li><li><code>可选的返回关键字：</code><br>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li></ul><p>Lambda体不加{ }就不用写return:</p><pre><code> Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(y, x); </code></pre><p>  Lambda体加上{ }就需要添加return:</p><pre><code>  Comparator&lt;Integer&gt; com = (x, y) -&gt; {            int compare = Integer.compare(y, x);            return compare;        }; </code></pre><h4 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h4><p>   上面我们看到了一个lambda表达式应该怎么写，但lambda中有一个重要特征是<code>可选参数类型声明</code>，就是说不用写参数的类型，那么为什么不用写呢？它是怎么知道的参数类型呢？这就涉及到类型推断了。</p><p><strong>java8的泛型类型推断改进：</strong></p><ul><li>支持通过方法上下文推断泛型目标类型</li><li>支持在方法调用链路中，泛型类型推断传递到最后一个方法</li></ul><pre><code>List&lt;Person&gt; ps = ...Stream&lt;String&gt; names = ps.stream().map(p -&gt; p.getName());</code></pre><p>  在上面的代码中，ps的类型是List<code>&lt;Person&gt;</code>，所以ps.stream()的返回类型是Stream<code>&lt;Person&gt;</code>。map()方法接收一个类型为Function&lt;T, R&gt;的函数式接口，这里T的类型即是Stream元素的类型，也就是Person，而R的类型未知。由于在重载解析之后lambda表达式的目标类型仍然未知，我们就需要推导R的类型：通过对lambda表达式lambda进行类型检查，我们发现lambda体返回String，因此R的类型是String，因而map()返回Stream<code>&lt;String&gt;</code>。绝大多数情况下编译器都能解析出正确的类型，但如果碰到无法解析的情况，我们则需要：</p><ul><li>使用显式lambda表达式（为参数p提供显式类型）以提供额外的类型信息</li><li>把lambda表达式转型为Function&lt;Person, String&gt;</li><li>为泛型参数R提供一个实际类型。（ <code>&lt;String&gt;</code>map(p -&gt; p.getName())）</li></ul><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>方法引用是用来直接访问类或者实例已经存在的方法或构造方法，提供了一种引用而不执行方法的方式。是一种更简洁更易懂的Lambda表达式，当Lambda表达式中只是执行一个方法调用时，直接使用方法引用的形式可读性更高一些。<br> 方法引用使用 “ :: ” 操作符来表示，左边是类名或实例名，右边是方法名。<br><code>（注意：方法引用::右边的方法名是不需要加（）的，例：User::getName）</code></p><p><strong>方法引用的几种形式：</strong></p><ul><li>类 :: 静态方法</li><li>类 :: 实例方法</li><li>对象 :: 实例方法</li></ul><pre><code>例如：    Consumer&lt;String&gt; consumer = (s) -&gt; System.out.println(s);等同于：    Consumer&lt;String&gt; consumer = System.out::println;例如：    Function&lt;String, Integer&gt; stringToInteger = (String s) -&gt; Integer.parseInt(s);等同于：    Function&lt;String, Integer&gt; stringToInteger = Integer::parseInt;例如：    BiPredicate&lt;List&lt;String&gt;, String&gt; contains = (list, element) -&gt; list.contains(element);等同于：    BiPredicate&lt;List&lt;String&gt;, String&gt; contains = List::contains;</code></pre><p><strong><code>注意:</code></strong></p><ul><li>Lambda体中调用方法的参数列表与返回值类型，要与函数式接口中抽象方法的函数列表和返回值类型保存一致</li><li>若Lambda参数列表中的第一个参数是实例方法的调用者，而第二个参数是实例方法的参数时，可以使用ClassName::method</li></ul><h4 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h4><p>语法格式：类名::new</p><pre><code>例如：    Supplier&lt;User&gt; supplier = ()-&gt;new User();等同于：    Supplier&lt;User&gt; supplier = User::new;</code></pre><p><strong><code>注意:</code></strong><br>需要调用的构造器方法与函数式接口中抽象方法的参数列表保持一致。</p><h4 id="Lambda是怎么实现的？"><a href="#Lambda是怎么实现的？" class="headerlink" title="Lambda是怎么实现的？"></a>Lambda是怎么实现的？</h4><p>研究了半天Lambda怎么写，可是它的原理是什么？我们简单看个例子，看看真相到底是什么：</p><pre><code>public class StreamTest {    public static void main(String[] args) {        printString(&quot;hello lambda&quot;, (String s) -&gt; System.out.println(s));    }    public static void printString(String s, Print&lt;String&gt; print) {        print.print(s);    }}@FunctionalInterfaceinterface Print&lt;T&gt; {    public void print(T t);}</code></pre><p> 上面的代码自定义了一个函数式接口，定义一个静态方法然后用这个函数式接口来接收参数。编写完这个类以后，我们到终端界面javac进行编译，然后用javap（javap是jdk自带的反解析工具。它的作用就是根据class字节码文件，反解析出当前类对应的code区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等等信息。）进行解析，如下图：</p><ul><li>执行javap -p 命令 (  -p  -private             显示所有类和成员)<br><img src="https://user-gold-cdn.xitu.io/2019/7/16/16bf81c31491a04a?w=990&h=286&f=png&s=346959" alt><br>看上图发现在编译Lambda表达式生成了一个<code>lambda$main$0</code>静态方法，这个静态方法实现了Lambda表达式的逻辑，现在我们知道原来Lambda表达式被编译成了一个静态方法，那么这个静态方式是怎么调用的呢？我们继续进行</li><li>执行javap -v -p 命令 (  -v  -verbose             输出附加信息)</li></ul><pre><code>  public com.lxs.stream.StreamTest();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: return      LineNumberTable:        line 7: 0  public static void main(java.lang.String[]);    descriptor: ([Ljava/lang/String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=2, locals=1, args_size=1         0: ldc           #2                  // String hello lambda         2: invokedynamic #3,  0              // InvokeDynamic #0:print:()Lcom/lxs/stream/Print;         7: invokestatic  #4                  // Method printString:(Ljava/lang/String;Lcom/lxs/stream/Print;)V        10: return      LineNumberTable:        line 10: 0        line 12: 10  public static void printString(java.lang.String, com.lxs.stream.Print&lt;java.lang.String&gt;);    descriptor: (Ljava/lang/String;Lcom/lxs/stream/Print;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=2, locals=2, args_size=2         0: aload_1         1: aload_0         2: invokeinterface #5,  2            // InterfaceMethod com/lxs/stream/Print.print:(Ljava/lang/Object;)V         7: return      LineNumberTable:        line 15: 0        line 16: 7    Signature: #19                          // (Ljava/lang/String;Lcom/lxs/stream/Print&lt;Ljava/lang/String;&gt;;)V  private static void lambda$main$0(java.lang.String);    descriptor: (Ljava/lang/String;)V    flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC    Code:      stack=2, locals=1, args_size=1         0: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;         3: aload_0         4: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V         7: return      LineNumberTable:        line 10: 0}SourceFile: &quot;StreamTest.java&quot;InnerClasses:     public static final #58= #57 of #61; //Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandlesBootstrapMethods:  0: #27 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;    Method arguments:      #28 (Ljava/lang/Object;)V      #29 invokestatic com/lxs/stream/StreamTest.lambda$main$0:(Ljava/lang/String;)V      #30 (Ljava/lang/String;)V</code></pre><p>这里只贴出了一部分的字节码结构，由于常量池定义太长了，就没有粘贴。</p><pre><code>InnerClasses:     public static final #58= #57 of #61; //Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandlesBootstrapMethods:  0: #27 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;    Method arguments:      #28 (Ljava/lang/Object;)V      #29 invokestatic com/lxs/stream/StreamTest.lambda$main$0:(Ljava/lang/String;)V      #30 (Ljava/lang/String;)V</code></pre><p>通过这段字节码结构发现是要生成一个内部类，使用invokestatic调用了一个LambdaMetafactory.metafactory方法，并把<code>lambda$main$0</code>作为参数传了进去，我们来看metafactory 的方法里的实现代码：</p><pre><code>    public static CallSite metafactory(MethodHandles.Lookup caller,                                       String invokedName,                                       MethodType invokedType,                                       MethodType samMethodType,                                       MethodHandle implMethod,                                       MethodType instantiatedMethodType)            throws LambdaConversionException {        AbstractValidatingLambdaMetafactory mf;        mf = new InnerClassLambdaMetafactory(caller, invokedType,                                             invokedName, samMethodType,                                             implMethod, instantiatedMethodType,                                             false, EMPTY_CLASS_ARRAY, EMPTY_MT_ARRAY);        mf.validateMetafactoryArgs();        return mf.buildCallSite();    }</code></pre><p>在buildCallSite的函数中,是函数spinInnerClass 构建了这个内部类。也就是生成了一个StreamTest$$Lambda$1.class这样的内部类,这个类是在运行的时候构建的，并不会保存在磁盘中。</p><pre><code>    @Override    CallSite buildCallSite() throws LambdaConversionException {        final Class&lt;?&gt; innerClass = spinInnerClass();        以下省略。。。    }</code></pre><p>如果想看到这个构建的类，可以通过设置环境参数<br>System.setProperty(“jdk.internal.lambda.dumpProxyClasses”, “ . “);<br>会在你指定的路径 . 当前运行路径上生成这个内部类。我们看下一下生成的类长什么样<br><img src="https://user-gold-cdn.xitu.io/2019/7/16/16bf81c31b9be099?w=1772&h=286&f=png&s=297718" alt><br>从图中可以看出动态生成的内部类实现了我自定义的函数式接口，并且重写了函数式接口中的方法。</p><p>我们在javap -v -p StreamTest$$Lambda$1.class看下：</p><pre><code>{  private com.lxs.stream.StreamTest$$Lambda$1();    descriptor: ()V    flags: ACC_PRIVATE    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #10                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: return  public void print(java.lang.Object);    descriptor: (Ljava/lang/Object;)V    flags: ACC_PUBLIC    Code:      stack=1, locals=2, args_size=2         0: aload_1         1: checkcast     #15                 // class java/lang/String         4: invokestatic  #21                 // Method com/lxs/stream/StreamTest.lambda$main$0:(Ljava/lang/String;)V         7: return    RuntimeVisibleAnnotations:      0: #13()}</code></pre><p>发现在重写的parint方法中使用invokestatic指令调用了lambda$main$0方法。</p><p><strong>总结：</strong><br>这样实现了Lambda表达式，使用invokedynamic指令，运行时调用LambdaMetafactory.metafactory动态的生成内部类，实现了函数式接口，并在重写函数式接口中的方法，在方法内调用<code>lambda$main$0</code>，内部类里的调用方法块并不是动态生成的，只是在原class里已经编译生成了一个静态的方法，内部类只需要调用该静态方法。</p><blockquote><p>感谢大家的观看，希望多多关注哦。 如有错误，烦请指正。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Go学习笔记」1.初识Go</title>
      <link href="/2019/10/30/go-xue-xi-bi-ji-1-chu-shi-go/"/>
      <url>/2019/10/30/go-xue-xi-bi-ji-1-chu-shi-go/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>由于在公司广泛使用Docker的大环境下，突然对它的编程语言（Go）了解下。并且感觉现在Go语言的应用也是越来越广泛，很多互联网大厂都在使用，目前利用业余时间来学习下，主流还是Java，学明白以后可能考虑转哦🤡。如果你也感兴趣不如一起来学习。</p><h4 id="Go介绍"><a href="#Go介绍" class="headerlink" title="Go介绍"></a>Go介绍</h4><ul><li><p>简史</p><p>Go语言是Google于2009年正式发布的一款开源的静态编译型语言。Go语言最早于2007年Robert Griesemer(Java HotSpot虚拟机、V8引擎开发者之一)和Ken Thompson(贝尔实验室UNIX团队成员，C语言、UNIX和Plan9创始人之一)与Rob Pike三人在业余时间联合开发。（<code>老外就是吊</code>）时至今日Go语言已完成自举，社区生态斐然，包括大量拿的出手的杀手锏级项目（Moby、Docker、Kubernetes、Gogs、Grafana、Etcd）。</p></li><li><p>特性</p><ol><li>Go语言拥有自动垃圾回收功能，同时也允许开发人员干预回收操作。</li><li>Go语言有着更加丰富的内置类型，在错误处理方面语法更加精简高效。</li><li>Go语言函数支持多个返回值，而函数也是一种类型，可以作为参数传递。</li><li>Go语言对多核处理器编程进行了优化，可以从程序与结构方面来实现并发编程。</li><li>Go语言初次编译速度媲美C/C++,甚至二次编译的速度明显快于C/C++，同时又拥有接近于Python等解释型语言的简洁。</li></ol></li><li><p>命名规范</p><p>Go语言的项目命名一般采用 【域名+项目名】，例如：github.com/example,这样命名的目录一是可以分割项目，不容易重名，二是能够迅速找到原项目的地址，三是方便获取代码包。</p></li><li><p>代码强制格式化</p><p>Go语言有一个特色就是强制代码格式化，在你保存代码之后，可以使用go fmt工具格式化，当然即使没有手动格式化，在编译时，Go语言编译器也会自动格式化所有源代码，这种强制格式化的做法可以有效统一编码风格。</p></li></ul><h4 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h4><p>目前Go语言支持Linux、FreeBSD、Mac OS、和Windows平台，安装包可以从 <a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">https://golang.google.cn/dl/</a> 下载。</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/12/16dbe83fa456c748?w=1089&h=601&f=png&s=126174" alt></p><h4 id="基本命令及使用"><a href="#基本命令及使用" class="headerlink" title="基本命令及使用"></a>基本命令及使用</h4><ul><li><p>基本命令<br>安装Go语言环境后就可以使用go命令了，直接输入go help查看有哪些命令可用：</p><pre><code>$ go help  go是用于管理Go语言源代码的工具。  用法：      go command [arguments]  包含的命令如下：  - build: 编译源代码包和依赖。  - clean: 删除对象文件。  - doc: 显示Go包或程序实体的文档。  - env: 打印输出Go语言环境的变量信息。  - bug: bug提交程序。  - fix: 修复程序。  - fmt: 格式化源码包中代码。  - generate: 通过扫描Go源码中的go:generate注释来识别要运行的常规命令。  - get: 下载并安装指定的包与依赖。  - install: 编译并安装指定的包与依赖。  - list: 打印指定源码包信息。  - run: 编译并运行Go程序。  - test: 测试一个源码包。  - tool: 运行一个指定的tool。  - version: 打印输出Go环境版本。  - vet: 检查源码包中可能出现的错误。  使用&quot;go help [command]&quot;查看每一个命令的使用细节。</code></pre></li><li><p>目录结构</p><ol><li><p>GOROOT结构</p><p>$GOROOT 作为Go语言环境的根目录，放置了下面这些内容：</p></li></ol><pre><code>&amp; cd $GOROOT &amp;&amp; ls -l-rw-r--r--    1 root  wheel  55389  9 26 02:52 AUTHORS    # 所有参与Go语言开发的人员名单-rw-r--r--    1 root  wheel   1339  9 26 02:52 CONTRIBUTING.md    # 为Go语言贡献代码的说明-rw-r--r--    1 root  wheel  84339  9 26 02:52 CONTRIBUTORS   # 所有贡献者名单-rw-r--r--    1 root  wheel   1479  9 26 02:52 LICENSE    # Go语言的开源协议-rw-r--r--    1 root  wheel   1303  9 26 02:52 PATENTS    # Go语言专利说明-rw-r--r--    1 root  wheel   1607  9 26 02:52 README.md    # 说明文件-rw-r--r--    1 root  wheel    397  9 26 02:52 SECURITY.md-rw-r--r--    1 root  wheel      8  9 26 02:52 VERSION    # Go语言版本文件drwxr-xr-x   19 root  wheel    608  9 26 02:55 api  # Go语言API相关(变量、常量、函数)drwxr-xr-x    4 root  wheel    128  9 26 02:55 bin   # 用于存储标准命令执行文件，go、godoc、gofmt三件套drwxr-xr-x   50 root  wheel   1600  9 26 02:55 doc   # 存放标准库的文档-rw-r--r--    1 root  wheel   5686  9 26 02:52 favicon.ico  # Go语言的图标drwxr-xr-x    3 root  wheel     96  9 26 02:55 lib   # 存放一些特殊的库文件drwxr-xr-x   16 root  wheel    512  9 26 02:55 misc   # 辅助工具和说明drwxr-xr-x    6 root  wheel    192  9 26 02:55 pkg    # 存放Go语言标准库生成的文件-rw-r--r--    1 root  wheel     26  9 26 02:52 robots.txt    # 禁止搜索引擎索引本地启动的Go文档drwxr-xr-x   71 root  wheel   2272  9 26 02:55 src    # 存放GO语言自己的源代码drwxr-xr-x  327 root  wheel  10464  9 26 02:55 test   # 存放测试验证相关的文件</code></pre><ol start="2"><li><p>GOPATH结构</p><p>$GOPATH就是一个工作目录，我们开发GO语言程序就是在这里进行的，这个目录一般有三个文件夹：</p><pre><code>- bin: 存放go install生成的可执行文件前面把$GOPATH/bin路径加入PATH环境变量后就可以在全局任意位置使用这个文件夹内的执行文件。- pkg: 存放go编辑生成的文件。- src: 存放我们开发的Go项目的源代码，不用工程项目的代码已包名区分。</code></pre></li></ol></li></ul><h4 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h4><ul><li><p>Visual Studio Code</p><p>来自微软的开源编辑器Visual Studio Code的确是开发Go语言程序的好工具之一，庞大的生态系统使得它不仅仅是一个编辑器，它还拥有大部分Go语言开发过程中使用的工具链。</p></li><li><p>VIM-Go</p><p>VIM编辑器是大部分程序员的最爱之一，在VIM的生态中也有一款比较流行的GO语言开发插件—-VIM-GO，安装这个插件与安装其他VIM插件的方法一样。</p></li><li><p>Gogland</p><p>来自著名的Jetbrains公司开发的IDE（Goland）是一款专门为Go语言开发而设计的IDE。</p></li><li><p>LiteIDE</p><p>LiteIDE是一款专门为GO语言开发的跨平台轻量级集成开发环境，LiteIDE是开源的工具，代码托管在github上。</p></li></ul><h4 id="第一个Go程序"><a href="#第一个Go程序" class="headerlink" title="第一个Go程序"></a>第一个Go程序</h4><p>现在开始编写第一个程序了，创建一个组织目录，例如 code.local,然后建立一个项目名为hello-word,最终目录路径为$PATH/src/code.local/hello-word<br><img src="https://user-gold-cdn.xitu.io/2019/10/16/16dd0327863f47b1?w=1610&h=838&f=png&s=695373" alt><br>接来下使用vim 编辑一个main.go</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/16/16dd03ab2a011618?w=582&h=286&f=png&s=63707" alt><br>然后:wq保存，接来下可以直接使用go run命令运行程序。<br><img src="https://user-gold-cdn.xitu.io/2019/10/16/16dd03c1e1887a62?w=1216&h=284&f=png&s=163852" alt><br>到此我们就完成了第一个go程序。随着go语言越来越🔥，我对它也是很感兴趣，无奈没有太多的时间来学习，只能用周末来抽空看看，希望大家多多支持，如果你也对Go语言感兴趣，不妨点击下关注，一起学习。</p><blockquote><p>感谢大家的观看，希望多多关注哦。 如有错误，烦请指正。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
