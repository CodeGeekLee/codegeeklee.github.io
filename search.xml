<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>「Java8系列」神秘的Lambda</title>
      <link href="/2019/10/31/java8-xi-lie-shen-mi-de-lambda/"/>
      <url>/2019/10/31/java8-xi-lie-shen-mi-de-lambda/</url>
      
        <content type="html"><![CDATA[<h4 id="接触背景"><a href="#接触背景" class="headerlink" title="接触背景"></a>接触背景</h4><p>第一次接触lambda表达式时，感觉这个东西挺神奇的（高逼格），一个（）加-&gt;就能传递一段代码，当时公司项目中接手同事的代码，自己也对java8的特性不了解，看的也是一头雾水，之后就赶快看了下《java8实战》这本书，决定写一个java8特性系列的博客，既加深自己的印象，还能跟大家分享一下，希望大家多多指教😄。</p><h4 id="什么是Lambda？"><a href="#什么是Lambda？" class="headerlink" title="什么是Lambda？"></a>什么是Lambda？</h4><p>Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码(将代码像参数一样进行传递，称为行为参数化)。Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中），要做到这一点就需要了解，什么是函数式接口，这里先不做介绍，等下一篇在讲解。</p><p>首先先看一下lambda长什么样？<br>正常写法：</p><pre><code>new Thread(new Runnable() {    @Override    public void run() {       System.out.println(&quot;hello lambda&quot;);    }}).start();</code></pre><p>lambda写法：</p><pre><code>new Thread(    () -&gt; System.out.println(&quot;hello lambda&quot;)).start();</code></pre><p>怎么样？是不是感觉很简洁，没错，这就是lambda的魅力，他可以让你写出来的代码更简单、更灵活。</p><h4 id="Lambda怎么写？"><a href="#Lambda怎么写？" class="headerlink" title="Lambda怎么写？"></a>Lambda怎么写？</h4><p><img src="https://user-gold-cdn.xitu.io/2019/7/16/16bf81c30ea9b895?w=798&h=434&f=png&s=59257" alt><br>大家看一些上面的这个图，这就是lambda的语法，一个lambda分为三部分：参数列表、操作符、lambda体。以下是lambda表达式的重要特征：</p><ul><li><code>可选类型声明：</code><br>不需要声明参数类型，编译器可以统一识别参数值。也就说(s) -&gt; System.out.println(s)和<br>(String s) -&gt; System.out.println(s)是一样的编译器会进行类型推断所以不需要添加参数类型。</li><li><code>可选的参数圆括号：</code><br>一个参数无需定义圆括号，但多个参数需要定义圆括号。例如：<ol><li>s -&gt; System.out.println(s)  一个参数不需要添加圆括号。</li><li>(x, y) -&gt; Integer.compare(y, x) 两个参数添加了圆括号，否则编译器报错。</li></ol></li><li><code>可选的大括号：</code><br>如果主体包含了一个语句，就不需要使用大括号。<ol><li>s -&gt; System.out.println(s) , 不需要大括号.</li><li>(s) -&gt; {<pre><code>     if (s.equals(&quot;s&quot;)){        System.out.println(s);     }</code></pre>   };    需要大括号</li></ol></li><li><code>可选的返回关键字：</code><br>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li></ul><p>Lambda体不加{ }就不用写return:</p><pre><code> Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(y, x); </code></pre><p>  Lambda体加上{ }就需要添加return:</p><pre><code>  Comparator&lt;Integer&gt; com = (x, y) -&gt; {            int compare = Integer.compare(y, x);            return compare;        }; </code></pre><h4 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h4><p>   上面我们看到了一个lambda表达式应该怎么写，但lambda中有一个重要特征是<code>可选参数类型声明</code>，就是说不用写参数的类型，那么为什么不用写呢？它是怎么知道的参数类型呢？这就涉及到类型推断了。</p><p><strong>java8的泛型类型推断改进：</strong></p><ul><li>支持通过方法上下文推断泛型目标类型</li><li>支持在方法调用链路中，泛型类型推断传递到最后一个方法</li></ul><pre><code>List&lt;Person&gt; ps = ...Stream&lt;String&gt; names = ps.stream().map(p -&gt; p.getName());</code></pre><p>  在上面的代码中，ps的类型是List<code>&lt;Person&gt;</code>，所以ps.stream()的返回类型是Stream<code>&lt;Person&gt;</code>。map()方法接收一个类型为Function&lt;T, R&gt;的函数式接口，这里T的类型即是Stream元素的类型，也就是Person，而R的类型未知。由于在重载解析之后lambda表达式的目标类型仍然未知，我们就需要推导R的类型：通过对lambda表达式lambda进行类型检查，我们发现lambda体返回String，因此R的类型是String，因而map()返回Stream<code>&lt;String&gt;</code>。绝大多数情况下编译器都能解析出正确的类型，但如果碰到无法解析的情况，我们则需要：</p><ul><li>使用显式lambda表达式（为参数p提供显式类型）以提供额外的类型信息</li><li>把lambda表达式转型为Function&lt;Person, String&gt;</li><li>为泛型参数R提供一个实际类型。（ <code>&lt;String&gt;</code>map(p -&gt; p.getName())）</li></ul><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>方法引用是用来直接访问类或者实例已经存在的方法或构造方法，提供了一种引用而不执行方法的方式。是一种更简洁更易懂的Lambda表达式，当Lambda表达式中只是执行一个方法调用时，直接使用方法引用的形式可读性更高一些。<br> 方法引用使用 “ :: ” 操作符来表示，左边是类名或实例名，右边是方法名。<br><code>（注意：方法引用::右边的方法名是不需要加（）的，例：User::getName）</code></p><p><strong>方法引用的几种形式：</strong></p><ul><li>类 :: 静态方法</li><li>类 :: 实例方法</li><li>对象 :: 实例方法</li></ul><pre><code>例如：    Consumer&lt;String&gt; consumer = (s) -&gt; System.out.println(s);等同于：    Consumer&lt;String&gt; consumer = System.out::println;例如：    Function&lt;String, Integer&gt; stringToInteger = (String s) -&gt; Integer.parseInt(s);等同于：    Function&lt;String, Integer&gt; stringToInteger = Integer::parseInt;例如：    BiPredicate&lt;List&lt;String&gt;, String&gt; contains = (list, element) -&gt; list.contains(element);等同于：    BiPredicate&lt;List&lt;String&gt;, String&gt; contains = List::contains;</code></pre><p><strong><code>注意:</code></strong></p><ul><li>Lambda体中调用方法的参数列表与返回值类型，要与函数式接口中抽象方法的函数列表和返回值类型保存一致</li><li>若Lambda参数列表中的第一个参数是实例方法的调用者，而第二个参数是实例方法的参数时，可以使用ClassName::method</li></ul><h4 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h4><p>语法格式：类名::new</p><pre><code>例如：    Supplier&lt;User&gt; supplier = ()-&gt;new User();等同于：    Supplier&lt;User&gt; supplier = User::new;</code></pre><p><strong><code>注意:</code></strong><br>需要调用的构造器方法与函数式接口中抽象方法的参数列表保持一致。</p><h4 id="Lambda是怎么实现的？"><a href="#Lambda是怎么实现的？" class="headerlink" title="Lambda是怎么实现的？"></a>Lambda是怎么实现的？</h4><p>研究了半天Lambda怎么写，可是它的原理是什么？我们简单看个例子，看看真相到底是什么：</p><pre><code>public class StreamTest {    public static void main(String[] args) {        printString(&quot;hello lambda&quot;, (String s) -&gt; System.out.println(s));    }    public static void printString(String s, Print&lt;String&gt; print) {        print.print(s);    }}@FunctionalInterfaceinterface Print&lt;T&gt; {    public void print(T t);}</code></pre><p> 上面的代码自定义了一个函数式接口，定义一个静态方法然后用这个函数式接口来接收参数。编写完这个类以后，我们到终端界面javac进行编译，然后用javap（javap是jdk自带的反解析工具。它的作用就是根据class字节码文件，反解析出当前类对应的code区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等等信息。）进行解析，如下图：</p><ul><li>执行javap -p 命令 (  -p  -private             显示所有类和成员)<br><img src="https://user-gold-cdn.xitu.io/2019/7/16/16bf81c31491a04a?w=990&h=286&f=png&s=346959" alt><br>看上图发现在编译Lambda表达式生成了一个<code>lambda$main$0</code>静态方法，这个静态方法实现了Lambda表达式的逻辑，现在我们知道原来Lambda表达式被编译成了一个静态方法，那么这个静态方式是怎么调用的呢？我们继续进行</li><li>执行javap -v -p 命令 (  -v  -verbose             输出附加信息)</li></ul><pre><code>  public com.lxs.stream.StreamTest();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: return      LineNumberTable:        line 7: 0  public static void main(java.lang.String[]);    descriptor: ([Ljava/lang/String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=2, locals=1, args_size=1         0: ldc           #2                  // String hello lambda         2: invokedynamic #3,  0              // InvokeDynamic #0:print:()Lcom/lxs/stream/Print;         7: invokestatic  #4                  // Method printString:(Ljava/lang/String;Lcom/lxs/stream/Print;)V        10: return      LineNumberTable:        line 10: 0        line 12: 10  public static void printString(java.lang.String, com.lxs.stream.Print&lt;java.lang.String&gt;);    descriptor: (Ljava/lang/String;Lcom/lxs/stream/Print;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=2, locals=2, args_size=2         0: aload_1         1: aload_0         2: invokeinterface #5,  2            // InterfaceMethod com/lxs/stream/Print.print:(Ljava/lang/Object;)V         7: return      LineNumberTable:        line 15: 0        line 16: 7    Signature: #19                          // (Ljava/lang/String;Lcom/lxs/stream/Print&lt;Ljava/lang/String;&gt;;)V  private static void lambda$main$0(java.lang.String);    descriptor: (Ljava/lang/String;)V    flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC    Code:      stack=2, locals=1, args_size=1         0: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;         3: aload_0         4: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V         7: return      LineNumberTable:        line 10: 0}SourceFile: &quot;StreamTest.java&quot;InnerClasses:     public static final #58= #57 of #61; //Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandlesBootstrapMethods:  0: #27 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;    Method arguments:      #28 (Ljava/lang/Object;)V      #29 invokestatic com/lxs/stream/StreamTest.lambda$main$0:(Ljava/lang/String;)V      #30 (Ljava/lang/String;)V</code></pre><p>这里只贴出了一部分的字节码结构，由于常量池定义太长了，就没有粘贴。</p><pre><code>InnerClasses:     public static final #58= #57 of #61; //Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandlesBootstrapMethods:  0: #27 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;    Method arguments:      #28 (Ljava/lang/Object;)V      #29 invokestatic com/lxs/stream/StreamTest.lambda$main$0:(Ljava/lang/String;)V      #30 (Ljava/lang/String;)V</code></pre><p>通过这段字节码结构发现是要生成一个内部类，使用invokestatic调用了一个LambdaMetafactory.metafactory方法，并把<code>lambda$main$0</code>作为参数传了进去，我们来看metafactory 的方法里的实现代码：</p><pre><code>    public static CallSite metafactory(MethodHandles.Lookup caller,                                       String invokedName,                                       MethodType invokedType,                                       MethodType samMethodType,                                       MethodHandle implMethod,                                       MethodType instantiatedMethodType)            throws LambdaConversionException {        AbstractValidatingLambdaMetafactory mf;        mf = new InnerClassLambdaMetafactory(caller, invokedType,                                             invokedName, samMethodType,                                             implMethod, instantiatedMethodType,                                             false, EMPTY_CLASS_ARRAY, EMPTY_MT_ARRAY);        mf.validateMetafactoryArgs();        return mf.buildCallSite();    }</code></pre><p>在buildCallSite的函数中,是函数spinInnerClass 构建了这个内部类。也就是生成了一个StreamTest$$Lambda$1.class这样的内部类,这个类是在运行的时候构建的，并不会保存在磁盘中。</p><pre><code>    @Override    CallSite buildCallSite() throws LambdaConversionException {        final Class&lt;?&gt; innerClass = spinInnerClass();        以下省略。。。    }</code></pre><p>如果想看到这个构建的类，可以通过设置环境参数<br>System.setProperty(“jdk.internal.lambda.dumpProxyClasses”, “ . “);<br>会在你指定的路径 . 当前运行路径上生成这个内部类。我们看下一下生成的类长什么样<br><img src="https://user-gold-cdn.xitu.io/2019/7/16/16bf81c31b9be099?w=1772&h=286&f=png&s=297718" alt><br>从图中可以看出动态生成的内部类实现了我自定义的函数式接口，并且重写了函数式接口中的方法。</p><p>我们在javap -v -p StreamTest$$Lambda$1.class看下：</p><pre><code>{  private com.lxs.stream.StreamTest$$Lambda$1();    descriptor: ()V    flags: ACC_PRIVATE    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #10                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: return  public void print(java.lang.Object);    descriptor: (Ljava/lang/Object;)V    flags: ACC_PUBLIC    Code:      stack=1, locals=2, args_size=2         0: aload_1         1: checkcast     #15                 // class java/lang/String         4: invokestatic  #21                 // Method com/lxs/stream/StreamTest.lambda$main$0:(Ljava/lang/String;)V         7: return    RuntimeVisibleAnnotations:      0: #13()}</code></pre><p>发现在重写的parint方法中使用invokestatic指令调用了lambda$main$0方法。</p><p><strong>总结：</strong><br>这样实现了Lambda表达式，使用invokedynamic指令，运行时调用LambdaMetafactory.metafactory动态的生成内部类，实现了函数式接口，并在重写函数式接口中的方法，在方法内调用<code>lambda$main$0</code>，内部类里的调用方法块并不是动态生成的，只是在原class里已经编译生成了一个静态的方法，内部类只需要调用该静态方法。</p><blockquote><p>感谢大家的观看，希望多多关注哦。 如有错误，烦请指正。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Go学习笔记」1.初识Go</title>
      <link href="/2019/10/30/go-xue-xi-bi-ji-1-chu-shi-go/"/>
      <url>/2019/10/30/go-xue-xi-bi-ji-1-chu-shi-go/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>由于在公司广泛使用Docker的大环境下，突然对它的编程语言（Go）了解下。并且感觉现在Go语言的应用也是越来越广泛，很多互联网大厂都在使用，目前利用业余时间来学习下，主流还是Java，学明白以后可能考虑转哦🤡。如果你也感兴趣不如一起来学习。</p><h4 id="Go介绍"><a href="#Go介绍" class="headerlink" title="Go介绍"></a>Go介绍</h4><ul><li><p>简史</p><p>Go语言是Google于2009年正式发布的一款开源的静态编译型语言。Go语言最早于2007年Robert Griesemer(Java HotSpot虚拟机、V8引擎开发者之一)和Ken Thompson(贝尔实验室UNIX团队成员，C语言、UNIX和Plan9创始人之一)与Rob Pike三人在业余时间联合开发。（<code>老外就是吊</code>）时至今日Go语言已完成自举，社区生态斐然，包括大量拿的出手的杀手锏级项目（Moby、Docker、Kubernetes、Gogs、Grafana、Etcd）。</p></li><li><p>特性</p><ol><li>Go语言拥有自动垃圾回收功能，同时也允许开发人员干预回收操作。</li><li>Go语言有着更加丰富的内置类型，在错误处理方面语法更加精简高效。</li><li>Go语言函数支持多个返回值，而函数也是一种类型，可以作为参数传递。</li><li>Go语言对多核处理器编程进行了优化，可以从程序与结构方面来实现并发编程。</li><li>Go语言初次编译速度媲美C/C++,甚至二次编译的速度明显快于C/C++，同时又拥有接近于Python等解释型语言的简洁。</li></ol></li><li><p>命名规范</p><p>Go语言的项目命名一般采用 【域名+项目名】，例如：github.com/example,这样命名的目录一是可以分割项目，不容易重名，二是能够迅速找到原项目的地址，三是方便获取代码包。</p></li><li><p>代码强制格式化</p><p>Go语言有一个特色就是强制代码格式化，在你保存代码之后，可以使用go fmt工具格式化，当然即使没有手动格式化，在编译时，Go语言编译器也会自动格式化所有源代码，这种强制格式化的做法可以有效统一编码风格。</p></li></ul><h4 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h4><p>目前Go语言支持Linux、FreeBSD、Mac OS、和Windows平台，安装包可以从 <a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">https://golang.google.cn/dl/</a> 下载。</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/12/16dbe83fa456c748?w=1089&h=601&f=png&s=126174" alt></p><h4 id="基本命令及使用"><a href="#基本命令及使用" class="headerlink" title="基本命令及使用"></a>基本命令及使用</h4><ul><li><p>基本命令<br>安装Go语言环境后就可以使用go命令了，直接输入go help查看有哪些命令可用：</p><pre><code>$ go help  go是用于管理Go语言源代码的工具。  用法：      go command [arguments]  包含的命令如下：  - build: 编译源代码包和依赖。  - clean: 删除对象文件。  - doc: 显示Go包或程序实体的文档。  - env: 打印输出Go语言环境的变量信息。  - bug: bug提交程序。  - fix: 修复程序。  - fmt: 格式化源码包中代码。  - generate: 通过扫描Go源码中的go:generate注释来识别要运行的常规命令。  - get: 下载并安装指定的包与依赖。  - install: 编译并安装指定的包与依赖。  - list: 打印指定源码包信息。  - run: 编译并运行Go程序。  - test: 测试一个源码包。  - tool: 运行一个指定的tool。  - version: 打印输出Go环境版本。  - vet: 检查源码包中可能出现的错误。  使用&quot;go help [command]&quot;查看每一个命令的使用细节。</code></pre></li><li><p>目录结构</p><ol><li><p>GOROOT结构</p><p>$GOROOT 作为Go语言环境的根目录，放置了下面这些内容：</p></li></ol><pre><code>&amp; cd $GOROOT &amp;&amp; ls -l-rw-r--r--    1 root  wheel  55389  9 26 02:52 AUTHORS    # 所有参与Go语言开发的人员名单-rw-r--r--    1 root  wheel   1339  9 26 02:52 CONTRIBUTING.md    # 为Go语言贡献代码的说明-rw-r--r--    1 root  wheel  84339  9 26 02:52 CONTRIBUTORS   # 所有贡献者名单-rw-r--r--    1 root  wheel   1479  9 26 02:52 LICENSE    # Go语言的开源协议-rw-r--r--    1 root  wheel   1303  9 26 02:52 PATENTS    # Go语言专利说明-rw-r--r--    1 root  wheel   1607  9 26 02:52 README.md    # 说明文件-rw-r--r--    1 root  wheel    397  9 26 02:52 SECURITY.md-rw-r--r--    1 root  wheel      8  9 26 02:52 VERSION    # Go语言版本文件drwxr-xr-x   19 root  wheel    608  9 26 02:55 api  # Go语言API相关(变量、常量、函数)drwxr-xr-x    4 root  wheel    128  9 26 02:55 bin   # 用于存储标准命令执行文件，go、godoc、gofmt三件套drwxr-xr-x   50 root  wheel   1600  9 26 02:55 doc   # 存放标准库的文档-rw-r--r--    1 root  wheel   5686  9 26 02:52 favicon.ico  # Go语言的图标drwxr-xr-x    3 root  wheel     96  9 26 02:55 lib   # 存放一些特殊的库文件drwxr-xr-x   16 root  wheel    512  9 26 02:55 misc   # 辅助工具和说明drwxr-xr-x    6 root  wheel    192  9 26 02:55 pkg    # 存放Go语言标准库生成的文件-rw-r--r--    1 root  wheel     26  9 26 02:52 robots.txt    # 禁止搜索引擎索引本地启动的Go文档drwxr-xr-x   71 root  wheel   2272  9 26 02:55 src    # 存放GO语言自己的源代码drwxr-xr-x  327 root  wheel  10464  9 26 02:55 test   # 存放测试验证相关的文件</code></pre><ol start="2"><li><p>GOPATH结构</p><p>$GOPATH就是一个工作目录，我们开发GO语言程序就是在这里进行的，这个目录一般有三个文件夹：</p><pre><code>- bin: 存放go install生成的可执行文件前面把$GOPATH/bin路径加入PATH环境变量后就可以在全局任意位置使用这个文件夹内的执行文件。- pkg: 存放go编辑生成的文件。- src: 存放我们开发的Go项目的源代码，不用工程项目的代码已包名区分。</code></pre></li></ol></li></ul><h4 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h4><ul><li><p>Visual Studio Code</p><p>来自微软的开源编辑器Visual Studio Code的确是开发Go语言程序的好工具之一，庞大的生态系统使得它不仅仅是一个编辑器，它还拥有大部分Go语言开发过程中使用的工具链。</p></li><li><p>VIM-Go</p><p>VIM编辑器是大部分程序员的最爱之一，在VIM的生态中也有一款比较流行的GO语言开发插件—-VIM-GO，安装这个插件与安装其他VIM插件的方法一样。</p></li><li><p>Gogland</p><p>来自著名的Jetbrains公司开发的IDE（Goland）是一款专门为Go语言开发而设计的IDE。</p></li><li><p>LiteIDE</p><p>LiteIDE是一款专门为GO语言开发的跨平台轻量级集成开发环境，LiteIDE是开源的工具，代码托管在github上。</p></li></ul><h4 id="第一个Go程序"><a href="#第一个Go程序" class="headerlink" title="第一个Go程序"></a>第一个Go程序</h4><p>现在开始编写第一个程序了，创建一个组织目录，例如 code.local,然后建立一个项目名为hello-word,最终目录路径为$PATH/src/code.local/hello-word<br><img src="https://user-gold-cdn.xitu.io/2019/10/16/16dd0327863f47b1?w=1610&h=838&f=png&s=695373" alt><br>接来下使用vim 编辑一个main.go</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/16/16dd03ab2a011618?w=582&h=286&f=png&s=63707" alt><br>然后:wq保存，接来下可以直接使用go run命令运行程序。<br><img src="https://user-gold-cdn.xitu.io/2019/10/16/16dd03c1e1887a62?w=1216&h=284&f=png&s=163852" alt><br>到此我们就完成了第一个go程序。随着go语言越来越🔥，我对它也是很感兴趣，无奈没有太多的时间来学习，只能用周末来抽空看看，希望大家多多支持，如果你也对Go语言感兴趣，不妨点击下关注，一起学习。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
