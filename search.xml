<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>手撕数据结构与算法-链表</title>
      <link href="/2019/12/13/shou-si-shu-ju-jie-gou-yu-suan-fa-lian-biao/"/>
      <url>/2019/12/13/shou-si-shu-ju-jie-gou-yu-suan-fa-lian-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>底层基础决定上层发展。</p><p>点个赞在看，让我知道你在关注技术。</p><p>本系列文章Github <a href="https://github.com/CodeGeekLee/data-structures-and-algorithms" target="_blank" rel="noopener">后端进阶指南 </a> 已收录，此项目正在完善中，欢迎star。</p></blockquote><p><strong>本系列内容预览：</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/12/9/16eeb2515423ba3e?w=1664&h=1276&f=png&s=411513" alt></p><h2 id="1-什么是链表？"><a href="#1-什么是链表？" class="headerlink" title="1. 什么是链表？"></a>1. 什么是链表？</h2><blockquote><p>链表也是<code>线性表</code>中的一种，数组是线性表中的<code>顺序结构</code>，而这次说的链表是线性表的<code>链式存储结构</code>，它在内存中是非连续、非顺序性的数据结构，由若干个节点组成。它每个节点中都会存储数据和下一个节点的地址，存储数据的叫做数据域，存储地址的叫做指针域。指针分为前驱指针、后继指针，分别用来记录前一个节点和后一个节点的位置。</p><p>指针：将某个变量赋值给指针，实际上就是将变量的地址值赋值给指针，可以看做Java当中的引用。</p></blockquote><h3 id="1-1-单向链表"><a href="#1-1-单向链表" class="headerlink" title="1.1 单向链表"></a>1.1 单向链表</h3><p><img src="https://user-gold-cdn.xitu.io/2019/12/4/16ed0675e43fef78?w=1476&h=326&f=png&s=28582" alt></p><p>单向链表，顾名思义就是只有一个方向的链表，从上图中来看，一个单向链表由若干个节点组成，每个节点又分为两个部分，一部分存放数据，一部分存放下一个节点的位置。用图来说话就是橘色的方块叫做<code>数据域</code>，里面用来存放数据data。而黄色的方块叫做<code>指针域</code>，用来存放下一个节点的位置next（<code>注意是下一个节点的位置，不是下一个指针的位置</code>），这个next又被称为后继指针。</p><p>大家观察上面的图，有两个地方比较特殊，那就是第一个节点和最后一个节点。我们还可以称作<code>头结点</code>、<code>尾结点</code>。这两个节点有什么特别之处呢？那就是头结点可以不存数据，作为链表的开始，而尾结点的后继指针指向null，代表这是链表的最后一个节点。</p><blockquote><p>头节点：链表中第一个节点，头节点中可以不存储数据。</p><p>头指针：链表中第一个节点的指针，用来存储链表的基地址，是整个链表的开始。</p><p>尾节点：链表中最后一个节点，指向一个空null，代表这是链表的最后一个节点。</p></blockquote><h3 id="1-2-单向循环链表"><a href="#1-2-单向循环链表" class="headerlink" title="1.2 单向循环链表"></a>1.2 单向循环链表</h3><p><img src="https://user-gold-cdn.xitu.io/2019/12/4/16ed0689d59690cd?w=1588&h=444&f=png&s=42339" alt></p><p>单向循环链表是从单向链表衍生出来的，它和单向链表的唯一区别就是单向链表的尾结点的后继指针指向了null，而单向循环链表的尾结点后继指针指向了头节点。这种首尾相连的单链表称<code>单向循环链表</code>。循环链表的优点就是从链尾到链头比较方便，处理环形结构问题时比较适用，比如著名的<a href="[https://baike.baidu.com/item/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98](https://baike.baidu.com/item/约瑟夫问题)">约瑟夫问题</a>。</p><h3 id="1-3-双向链表"><a href="#1-3-双向链表" class="headerlink" title="1.3 双向链表"></a>1.3 双向链表</h3><p><img src="https://user-gold-cdn.xitu.io/2019/12/4/16ed06bb63cdf646?w=1502&h=342&f=png&s=31917" alt></p><p>双向链表稍微复杂一些，它和单向链表相比除了后继指针以外还多了个前驱指针。如果存储同样多的数据，双向链表比单向链表占用更多的空间，虽然双向链表中的两个指针很浪费空间，但可以支持双向遍历，也给链表本身带来了更多的灵活性。</p><h3 id="1-4-双向循环链表"><a href="#1-4-双向循环链表" class="headerlink" title="1.4 双向循环链表"></a>1.4 双向循环链表</h3><p><img src="https://user-gold-cdn.xitu.io/2019/12/4/16ed0b8f695d0ba7?w=1580&h=571&f=png&s=60582" alt></p><p>了解了循环链表和双向链表之后，把这两个组合在一起就是双向循环链表，大家看图就知道了，头节点的前驱指针指向尾节点，尾节点的后继指针指向头节点。这里就不做过多介绍了，大家知道链表都有哪几种就可以了。</p><h2 id="2-链表VS数组"><a href="#2-链表VS数组" class="headerlink" title="2. 链表VS数组"></a>2. 链表VS数组</h2><p>说了半天链表，不知道大家了解了没有，我自己都感觉很枯燥。可是基础就是这样，只有学好了基础才能更好的向上爬。现在我们来看下链表和我们之前讲的数组有什么区别。首先它们两个的存储结构就不一样，数组是顺序存储结构，也就是说它在内存中是一块连续的存储空间，而链表是链式存储结构，也就是非连续的。我们来看下它们在内存中表现：</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/5/16ed67dc1d83ecd9?w=1192&h=462&f=png&s=44534" alt></p><p>通过图片，相信大家已经看出来区别了，由于数组是连续的存储结构，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。由于数据结构的不同，导致数组和链表的插入、删除、随机访问等操作的时间复杂度正好相反。</p><table><thead><tr><th align="left"></th><th>数组</th><th>链表</th></tr></thead><tbody><tr><td align="left">插入、删除</td><td><code>O(n)</code></td><td><code>O(1)</code></td></tr><tr><td align="left">随机访问</td><td><code>O(1)</code></td><td><code>O(n)</code></td></tr></tbody></table><p>链表天然的支持动态扩容，因为它不是预先生成内存空间，只有真正使用的时候才会去开辟一块内存空间。而数组就不行，数组的缺点就是大小固定，申请多了浪费，申请少了还得频繁的扩容、搬移数组，如果数据量大了很耗时。所以大家在使用List的时候也是，如果能够事先预估数据量的大小，那么在初始化的时候最好指定下大小，避免扩容时搬移数据带来影响。</p><h2 id="3-链表的基本操作"><a href="#3-链表的基本操作" class="headerlink" title="3. 链表的基本操作"></a>3. 链表的基本操作</h2><h3 id="3-1-链表的增加"><a href="#3-1-链表的增加" class="headerlink" title="3.1 链表的增加"></a>3.1 链表的增加</h3><p>链表的增加操作，一共有三种情况：</p><ul><li><p>增加到头部</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/8/16ee62db258947f7?w=1257&h=341&f=png&s=20299" alt></p><p>增加到头部一共分为两步，第一步将新节点的后继指针指向原头节点，第二步是将新节点变为头节点。这样就完成了头部添加。</p></li><li><p>增加到中间</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/8/16ee6366a77e1650?w=1186&h=451&f=png&s=33518" alt></p><p>中间插入也分为两步，第一步将插入位置的前边节点的后继指针指向新节点，第二步是将新节点后继指针指向插入位置的原节点。</p></li><li><p>增加到尾部</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/8/16ee63b1414962b4?w=1476&h=421&f=png&s=27386" alt></p><p>链表的尾部插入最简单，只需要将最后一个节点的后继指针指向新节点就可以了。</p></li></ul><blockquote><p>我们来看下代码，如果大家时间充沛，建议自己手动敲一遍，这样会理解的更深刻。</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author: lixiaoshuang * @create: 2019-12-08 23:11 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedListAddDemo</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//头节点</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Node headNode <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//尾节点</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Node lastNode <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//链表的长度</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//初始化一个链表</span>        <span class="token function">addByIndex</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addByIndex</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addByIndex</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addByIndex</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//头部插入</span>        <span class="token function">addByIndex</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出 5、1、2、3、4</span>        <span class="token comment" spellcheck="true">//中间插入</span>        <span class="token function">addByIndex</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出 1、2、5、3、4</span>        <span class="token comment" spellcheck="true">//尾部插入</span>        <span class="token function">addByIndex</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出 1、2、3、4、5</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">addByIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> index <span class="token operator">></span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token string">"超出链表节点范围"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Node node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//插入到头部</span>            node<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>headNode<span class="token punctuation">)</span><span class="token punctuation">;</span>            headNode <span class="token operator">=</span> node<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                lastNode <span class="token operator">=</span> node<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//插入到尾部</span>            lastNode<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            lastNode <span class="token operator">=</span> node<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//插入到中间</span>            Node prevNode <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Node nextNode <span class="token operator">=</span> prevNode<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            prevNode<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            node<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过位置查找链表节点     *     * @param index     * @return     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Node <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> index <span class="token operator">></span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token string">"超出链表节点范围"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Node temp <span class="token operator">=</span> headNode<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            temp <span class="token operator">=</span> temp<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 打印节点     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>headNode <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>headNode<span class="token punctuation">.</span><span class="token function">getDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            headNode <span class="token operator">=</span> headNode<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 定义一个节点 * * @param &lt;T> */</span><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 节点中的数据     */</span>    <span class="token keyword">private</span> T date<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 下一个节点的指针     */</span>    <span class="token keyword">private</span> Node next<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span>T date<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>date <span class="token operator">=</span> date<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Node <span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNext</span><span class="token punctuation">(</span>Node next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> T <span class="token function">getDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> date<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setDate</span><span class="token punctuation">(</span>T date<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>date <span class="token operator">=</span> date<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-链表的删除"><a href="#3-2-链表的删除" class="headerlink" title="3.2 链表的删除"></a>3.2 链表的删除</h3><p>链表删除和增加一样，也有三种情况：</p><ul><li><p>删除头部</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/9/16ee90f71abf0618?w=1086&h=136&f=png&s=15566" alt></p><p>删除头部操作只需要将头部节点设置为当前头部节点的下一个节点就可以了。</p></li><li><p>删除中间</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/9/16ee91339550fa83?w=1186&h=266&f=png&s=19394" alt></p><p>删除中间操作只需要将被删除节点的前一个节点的后继指针指向被删除节点的下一个节点就可以了。</p></li><li><p>删除尾部</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/9/16ee9104dfa40021?w=1186&h=236&f=png&s=17709" alt></p><p>尾部删除只需要将倒数第二个节点的后继指针指向null就可以。</p></li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author: lixiaoshuang * @create: 2019-12-08 23:11 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedListAddDemo</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//头节点</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Node headNode <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//尾节点</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Node lastNode <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//链表的长度</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//初始化一个链表</span>        <span class="token function">addByIndex</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addByIndex</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addByIndex</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addByIndex</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//头部删除</span>        <span class="token function">delete</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出 2、3、4</span>        <span class="token comment" spellcheck="true">//尾部删除</span>        <span class="token function">delete</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出 1、2、3</span>        <span class="token comment" spellcheck="true">//中间删除</span>        <span class="token function">delete</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出 1、2、4</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 链表删除操作     *     * @param index     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> index <span class="token operator">>=</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token string">"超出链表节点范围"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//删除头部</span>            headNode <span class="token operator">=</span> headNode<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//删除尾部</span>            Node prevNode <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            prevNode<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>            lastNode <span class="token operator">=</span> prevNode<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//删除中间</span>            Node prevNode <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Node nextNode <span class="token operator">=</span> prevNode<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            prevNode<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        size<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过位置查找链表节点     *     * @param index     * @return     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Node <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> index <span class="token operator">></span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token string">"超出链表节点范围"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Node temp <span class="token operator">=</span> headNode<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            temp <span class="token operator">=</span> temp<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 打印节点     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>headNode <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>headNode<span class="token punctuation">.</span><span class="token function">getDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            headNode <span class="token operator">=</span> headNode<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-链表的修改"><a href="#3-3-链表的修改" class="headerlink" title="3.3 链表的修改"></a>3.3 链表的修改</h3><p>修改链表节点就直接将要修改的节点替换为新节点，第一步先将被修改的节点的前一个节点的后继指针指向新节点，然后将新节点的后继指针指向被修改节点的下一个节点，这里讲的是如何修改一个节点，逻辑和上边的增加删除差不多，这里就举一个中间修改的图例吧。如果想不替换节点修改节点中的数据，这个比较简单，大家可以自己实现下。</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/9/16ee928290c8acee?w=1186&h=401&f=png&s=27659" alt></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author: lixiaoshuang * @create: 2019-12-08 23:11 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedListOperationDemo</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//头节点</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Node headNode <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//尾节点</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Node lastNode <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//链表的长度</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//初始化一个链表</span>        <span class="token function">addByIndex</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addByIndex</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addByIndex</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addByIndex</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//修改头部</span>        <span class="token function">update</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出 5、2、3、4</span>        <span class="token comment" spellcheck="true">//修改尾部</span>        <span class="token function">update</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出 1、2、3、5</span>        <span class="token comment" spellcheck="true">//修改中间</span>        <span class="token function">update</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出 1、5、3、4</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 链表的修改     *     * @param data     * @param index     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> index <span class="token operator">>=</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token string">"超出链表节点范围"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Node newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//修改头部</span>            Node next <span class="token operator">=</span> headNode<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            newNode<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>            headNode <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//修改尾部</span>            Node prevNode <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            prevNode<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>            lastNode <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//修改中间</span>            Node prevNode <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Node nextNode <span class="token operator">=</span> prevNode<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            prevNode<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>            newNode<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过位置查找链表节点     *     * @param index     * @return     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Node <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> index <span class="token operator">></span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token string">"超出链表节点范围"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Node temp <span class="token operator">=</span> headNode<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            temp <span class="token operator">=</span> temp<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 打印节点     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>headNode <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>headNode<span class="token punctuation">.</span><span class="token function">getDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            headNode <span class="token operator">=</span> headNode<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-链表的查询"><a href="#3-4-链表的查询" class="headerlink" title="3.4 链表的查询"></a>3.4 链表的查询</h3><p>说道查询，不知道大家发现没有，上边的代码中已经有过实现了😭,这里在贴过来，大家看下:</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 通过位置查找链表节点     *     * @param index     * @return     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Node <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> index <span class="token operator">></span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token string">"超出链表节点范围"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Node temp <span class="token operator">=</span> headNode<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            temp <span class="token operator">=</span> temp<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-面试题"><a href="#4-面试题" class="headerlink" title="4. 面试题"></a>4. 面试题</h2><h3 id="4-1-怎么判断一个单向链表是否有环？"><a href="#4-1-怎么判断一个单向链表是否有环？" class="headerlink" title="4.1 怎么判断一个单向链表是否有环？"></a>4.1 怎么判断一个单向链表是否有环？</h3><p>我们这里采用<code>快慢指针</code>的方法来判断一个链表是否有环，首先创建两个指针同时指向链表的头节点，慢指针走一步，快指针走两步，判断两个指针是否相等，如果相等，则说明有环。这里就是我们上边介绍的单向环形链表了。只要这个链表有环，那么利用快慢指针遍历它，两个指针肯定会有相等的时候（这里的指针是指节点）。这就好比周末公园里跑步一样，年轻人跑的快一些，老年人跑的慢一些，年轻人就会在某一个地方追赶上老人并超越他，原因很简单，因为公园的跑道是环形，哈哈。</p><p>大家看下面的代码我把链表插入操作中的尾部插入做了一个小修改，就是让每一个尾部节点的后继都指向头节点，这样就把单向链表变成了单向循环链表。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author: lixiaoshuang * @create: 2019-12-08 23:11 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedListOperationDemo</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//头节点</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Node headNode <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//尾节点</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Node lastNode <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//链表的长度</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//初始化一个链表</span>        <span class="token function">addByIndex</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addByIndex</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addByIndex</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addByIndex</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//判断链表是否有环</span>        <span class="token keyword">boolean</span> ringed <span class="token operator">=</span> <span class="token function">isRinged</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ringed<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出为true</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 判断链表是否有环     *     * @return     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isRinged</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>headNode <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//定义快慢指针</span>        Node slowPointer<span class="token punctuation">,</span> fastPointer<span class="token punctuation">;</span>        slowPointer <span class="token operator">=</span> fastPointer <span class="token operator">=</span> headNode<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>slowPointer <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fastPointer <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            slowPointer <span class="token operator">=</span> slowPointer<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            fastPointer <span class="token operator">=</span> fastPointer<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//如果两个指针有相等则有环</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>slowPointer <span class="token operator">==</span> fastPointer<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 链表插入操作     *     * @param data     * @param index     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">addByIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> index <span class="token operator">></span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token string">"超出链表节点范围"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Node node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//插入到头部</span>            node<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>headNode<span class="token punctuation">)</span><span class="token punctuation">;</span>            headNode <span class="token operator">=</span> node<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                lastNode <span class="token operator">=</span> node<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//插入到尾部</span>            lastNode<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            lastNode <span class="token operator">=</span> node<span class="token punctuation">;</span>            node<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>headNode<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//这里尾部插入将最后一个节点的后继指向头节点，这样链表就是循环链表了。</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//插入到中间</span>            Node prevNode <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Node nextNode <span class="token operator">=</span> prevNode<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            prevNode<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            node<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-如何实现链表的反转？"><a href="#4-2-如何实现链表的反转？" class="headerlink" title="4.2 如何实现链表的反转？"></a>4.2 如何实现链表的反转？</h3><blockquote><p>这个也是一个高频面试题，这里我就不写实现方式了，当给大家留个思考题，有时间的朋友可以尝试自己解一下，这道题虽然百度下解题方法就出来了，但还是希望大家先自己思考下，如果实在想不出来在查找一下解题方法。也可以去《<a href="https://github.com/CodeGeekLee/data-structures-and-algorithms" target="_blank" rel="noopener">手撕数据结构与算法</a>》中查看源码，我已经手敲了一遍。</p></blockquote><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h2><p>《漫画算法》</p><p>《数据结构与算法之美》</p><p>《大话数据结构》</p><h2 id="6-结尾"><a href="#6-结尾" class="headerlink" title="6.结尾"></a>6.结尾</h2><p>在我看来后端程序员应该学的有三大基础知识<code>&quot;数据结构与算法&quot;</code>、<code>&quot;计算机系统&quot;</code>、<code>&quot;操作系统Linux&quot;</code>。在这个互联网寒冬时代，是不是我们的衣服穿得不够多？彻夜难眠的我（<code>纯属扯淡，哈哈</code>）决定带领大家一起学习三大基础知识，本次开篇系列是《手撕数据结构与算法》，每一个系列更完就会开启下一个系列，大家不要着急。可以关注我的公众号，持续追更、持续学习。</p><blockquote><p>本系列文章Github <a href="https://github.com/CodeGeekLee/data-structures-and-algorithms" target="_blank" rel="noopener">后端进阶指南 </a> 已收录，此项目正在完善中，欢迎star。</p><p>公众号内文章都是博主原创，并且会一直更新。如果你想见证或和博主一起成长，欢迎关注！</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2019/12/9/16eeb502a1f2d09c?w=300&h=300&f=png&s=11666" alt="欢迎扫码关注哦！！！"></p><p>最后  最后，能够看到这里的朋友，都是有着乐于学习的精神，谢谢你们能够看完我写的文章，博主不太会总结，有什么问题欢迎留言指正，如果感觉读了以后有点收获 <strong>点赞、点关注</strong> 。写作路上需要各位老铁的支持，你们的支持就是下一篇得动力。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手撕数据结构与算法-数组</title>
      <link href="/2019/12/13/shou-si-shu-ju-jie-gou-yu-suan-fa-shu-zu/"/>
      <url>/2019/12/13/shou-si-shu-ju-jie-gou-yu-suan-fa-shu-zu/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>开篇一张图，知识全靠吹！</p><p>开篇点个赞，博主能上天！</p></blockquote><p> <img src="https://i.loli.net/2019/11/25/EvK4mpuixgl89I6.png" alt></p><p><strong>本系列文章已收录到github：</strong></p><ul><li><a href="https://github.com/CodeGeekLee/data-structures-and-algorithms" target="_blank" rel="noopener">手撕数据结构与算法</a></li></ul><h2 id="1-什么是数组？"><a href="#1-什么是数组？" class="headerlink" title="1. 什么是数组？"></a>1. 什么是数组？</h2><p>数组是数据结构中<code>最简单</code>、<code>最常用</code>的数据结构，是一种线性表数据结构，在内存中是一块<code>连续</code>的存储空间，是有限个<code>相同类型</code>变量所组成的<code>有序集合</code>。数组中的每一个变量叫做<code>元素</code>。</p><blockquote><p>线性表：线性表从字面意义上来理解是数据的排列像一条线的结构，只有前后两个方向。线性表中的元素都是一对一的关系，除了首尾元素外，其他元素都是首尾相连的。除了数组，链表、队列、栈也是线性表结构的。</p></blockquote><p>以整型数组为例，我们new一个整型数组<code>int[] array = new int[]{1,2,3,4};</code>，数组内的元素存储的元素是1、2、3、4。那么数组的存储形势就如下图：</p><p>  <img src="https://i.loli.net/2019/11/30/Q3PuZyrgFpCiIaB.png" alt="数组图解.png"></p><p>在上图中<code>粉色</code>的格子代表已经被占用了的存储单元，<code>绿色</code>的格子代表数组的存储位置，<code>白色</code>的格子代表空闲的存储单元。数组的下标是从0开始的。所以元素和下标的对应关系是：</p><p> <img src="https://i.loli.net/2019/11/30/ypVgOr35hamS8D9.png" alt></p><h2 id="2-数组的优缺点"><a href="#2-数组的优缺点" class="headerlink" title="2. 数组的优缺点"></a>2. 数组的优缺点</h2><p>谈起数组的优点，我相信大部分的人都会说<code>随机访问</code>这个堪称杀手锏的特性，那么它为什么能够做到随机访问呢？</p><p>我认为主要有两点：</p><ul><li>连续的存储空间</li><li>线性表结构</li></ul><p>正因为它是在内存中是一块连续的存储空间，并且是线性表结构，前后元素都是一一对应的，所以才能够让他拥有随机访问的特性。在上一篇文章<a href="https://mp.weixin.qq.com/s/sWpbqEWHCZCimjRcy2pMKw" target="_blank" rel="noopener">数据结构与算法-开篇</a>当中我们介绍了时间复杂度和空间复杂度，这里就不对说了，比如我们要查找上边的数组中的第三个元素，那么打印出<code>array[2]</code>就能够获取到第三个元素值，这里输出的是3，因为数组支持随机访问，所以根据下标随机访问的时间复杂度为<code>O(1)</code>，因为它的查找操作只执行了一次。</p><p>这样的结构使它的查询操作非常的方便，有利也有弊，它的插入、删除操作就会变得低效，因为要保证数据的连续性，所以执行插入、删除操作就需要做大量的数据搬移工作。如果这个时候一个数组的随机访问正好访问到没有值得下标上就会获取不到值。如果不搬移数据将中间的空洞补充上，那么内存就不连续了。我们在数组的操作中在详细介绍。</p><h2 id="3-数组的基本操作"><a href="#3-数组的基本操作" class="headerlink" title="3. 数组的基本操作"></a>3. 数组的基本操作</h2><h3 id="3-1-添加元素"><a href="#3-1-添加元素" class="headerlink" title="3.1 添加元素"></a>3.1 添加元素</h3><ul><li><p><strong>中间插入</strong></p><p>中间插入稍微复杂一些，每个元素都有自己的下标，如果一个元素想要插入到数组的中的除首尾的位置，那么插入的该位置上的元素都要向后移动，给新的位置腾出空间，保证连续性。</p><p> <img src="https://s2.ax1x.com/2019/11/30/QZM4nx.png" alt></p></li></ul><p>   <img src="https://s2.ax1x.com/2019/11/30/QZtetx.png" alt></p><ul><li><p><strong>尾部插入</strong></p><p>尾部插入这种情况比较简单，直接把元素放到数组尾部的空闲位置即可，等同于更新元素的操作。</p><p><img src="https://s2.ax1x.com/2019/11/30/QZlULq.png" alt></p><p><img src="https://s2.ax1x.com/2019/11/30/QZJyrj.png" alt="QZJyrj.png"></p></li></ul><p>​      </p><h3 id="3-2-删除元素"><a href="#3-2-删除元素" class="headerlink" title="3.2 删除元素"></a>3.2 删除元素</h3><p>删除操作和插入操作的过程正好相反，如果删除的元素在数组的中间，那么其后的元素都要向前移动。</p><p> <img src="https://s2.ax1x.com/2019/11/30/QZNRII.png" alt="QZNRII.png"></p><p>  <img src="https://s2.ax1x.com/2019/11/30/QZNqds.png" alt="QZNqds.png"></p><h3 id="3-3-更新元素"><a href="#3-3-更新元素" class="headerlink" title="3.3 更新元素"></a>3.3 更新元素</h3><p>​    <img src="https://i.loli.net/2019/11/30/kbqy2ualjm4ZSRr.png" alt="carbon (1).png"></p><blockquote><p>这里更新元素的时间复杂度为<code>O(1)</code>。</p></blockquote><h3 id="3-4-读取元素"><a href="#3-4-读取元素" class="headerlink" title="3.4 读取元素"></a>3.4 读取元素</h3><p> <img src="https://i.loli.net/2019/11/30/3qtLAzoUmJfvyjZ.png" alt="carbon.png"></p><blockquote><p>这里读元素的时间复杂度为<code>O(1)</code>。</p></blockquote><h2 id="4-容器能够代替数组吗？"><a href="#4-容器能够代替数组吗？" class="headerlink" title="4. 容器能够代替数组吗？"></a>4. 容器能够代替数组吗？</h2><p>针对数组类型，很多语言都提供了容器类，例如Java的List，如果你是一个Java程序员，那么你应该清楚ArrayList，对它应该非常的熟悉，和数组对比它有哪些优势呢？为什么开发的过程中经常使用它，最大的优势就是封装了对数组的操作，例如前面说的插入和删除，如果使用ArrayList还有一个优势是它支持动态扩容，当容器不够大的时候会自动扩容1.5倍，我们完全不需要关心底层的实现逻辑。那么什么时候使用数组更合适呢？有一下几点：</p><ul><li>ArrayList无法存储基本数据类型，例如int、long需要封装为Integer、Long。这里的装箱、拆箱操作有一定的性能损耗，如果特别关注性能，希望使用基本类型，那么就可以选择数组。</li><li>对数据只是简单的存储操作，那么选择数组效率更好些。</li><li>当做一些底层开发的时候数组可能用的比较多，比如一些框架。都是比较要求性能的。</li></ul><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h2><p>《漫画算法》</p><p>《数据结构与算法之美》</p><h2 id="6-结尾求关注环节"><a href="#6-结尾求关注环节" class="headerlink" title="6.结尾求关注环节"></a>6.结尾求关注环节</h2><p>在我看来后端程序员应该学的有三大基础知识<code>&quot;数据结构与算法&quot;</code>、<code>&quot;计算机系统&quot;</code>、<code>&quot;操作系统Linux&quot;</code>。在这个互联网寒冬时代，是不是我们的衣服穿得不够多？彻夜难眠的我（<code>纯属扯淡，哈哈</code>）决定带领大家一起学习三大基础知识，本次开篇系列是《手撕数据结构与算法》，每一个系列更完就会开启下一个系列，大家不要着急。可以关注我的公众号，持续追更、持续学习。</p><p><code>注意、注意 前方高能======&gt;</code></p><blockquote><p>如果你对我的这个系列感兴趣可以关注我的公众号，带你走上”超神之路、拿高薪offer、当上技术专家、出任个大厂、迎娶<a href="https://baike.baidu.com/item/白富美/9462281" target="_blank" rel="noopener">白富美</a>、走上人生巅峰，想想还有点小激动。” (哈哈，请允许我吹个🐂)</p><p>来了  来了  他来了  他带着二维码来了！！！</p><p><img src="https://i.loli.net/2019/11/24/fXyOTLCBcGMNKoj.png" alt="欢迎扫码关注哦！！！"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手撕数据结构与算法-开篇</title>
      <link href="/2019/11/25/shou-si-shu-ju-jie-gou-yu-suan-fa-kai-pian/"/>
      <url>/2019/11/25/shou-si-shu-ju-jie-gou-yu-suan-fa-kai-pian/</url>
      
        <content type="html"><![CDATA[<h3 id="1-浪子回头"><a href="#1-浪子回头" class="headerlink" title="1. 浪子回头"></a>1. 浪子回头</h3><p>2019年，这个不平凡的一年，中美<code>贸易战</code>、各个大厂<code>裁员</code>。造成了现在互联网行情不好，形势很严峻啊。有的人说今年是互联网过去十年中最差的一年，也可能是未来十年中最好的一年。身处这样乱世的我们怎么办？我也听很多朋友说，今年的面试都比较严格，特点是<code>&quot;要求高、薪资低&quot;</code>。也经常听见他们说某某大厂考了个手写算法，结果当场挂了。身为程序员的我们，再这样行业形势严峻、竞争压力大的情况下，只有不断提升自身能力，以确保在行业内能有个<code>立足之地</code>。</p><p>《数据结构与算法》在我学生时代就是一门让我望而止步的课程。听着名字就感觉很晦涩难懂、需要大量的数学知识做铺垫。相信很多人也都和我一样，上学的时候学的一知半解，到了工作以后也很少用到就不了了之了。但是它却成为了你面试、寻找好的平台的障碍。很多大厂都很看中程序员的<code>基本功</code>，所以在面试中算法就编程了常考题目，为什么呢？因为基础知识就像是一座大楼的地基，它能够决定你技术的<code>高度</code>与<code>深度</code>。所以一般大厂都是看中你有没有这个技术发展的潜力。<code>(&quot;所以大家要夯实基本功了。&quot;)</code></p><p>在我看来后端程序员应该学的有三大基础知识<code>&quot;数据结构与算法&quot;</code>、<code>&quot;计算机系统&quot;</code>、<code>&quot;操作系统Linux&quot;</code>。在这个人人都必须要手撕算法的时代，彻夜难眠的我（<code>纯属扯淡</code>）决定带领大家一起学习三大基础知识，本次开篇系列是《手撕数据结构与算法》，每一个系列更完就会开启下一个系列，大家不要着急。</p><p><code>注意,注意前方高能======&gt;(广告植入)</code>  </p><blockquote><p>如果你对我的这个系列感兴趣可以关注我的公众号，带你走上”超神之路、拿高薪offer、当上技术专家、出任个大厂、迎娶<a href="https://baike.baidu.com/item/白富美/9462281" target="_blank" rel="noopener">白富美</a>、走上人生巅峰，想想还有点小激动。” (请允许我吹个🐂)</p><p>来了  来了  他来了  他带着二维码来了！！！</p><p><img src="https://i.loli.net/2019/11/24/fXyOTLCBcGMNKoj.png" alt="欢迎扫码关注哦！！！"></p></blockquote><h3 id="2-数学知识复习"><a href="#2-数学知识复习" class="headerlink" title="2. 数学知识复习"></a>2. 数学知识复习</h3><p>在我们系统的学习数据结构与算法之前，我们先简单的复习几个数学知识，相信大家也都忘的差不多了，是不是都学完了又还给老师了呢？嫑急，跟我一起来复习一下。</p><h4 id="2-1-指数"><a href="#2-1-指数" class="headerlink" title="2.1. 指数"></a>2.1. 指数</h4><p>指数是幂运算aⁿ(a≠0)中的一个参数，a为底数，n为指数，指数位于底数的右上角，幂运算表示指数个底数相乘。当n是一个正整数，a<strong>ⁿ</strong>表示n个a连乘。当n=0时，aⁿ=1。《百度百科》</p><ul><li><code>指数：就是aⁿ中的n。</code></li><li><code>底数：就是aⁿ的a</code></li><li><code>幂运算：指数个底数相乘。</code></li></ul><p><strong>幂运算公式:</strong></p><ul><li>$a^{n}\cdot a^{m} =  a^{n+m}$    同底数相乘，底数不变，指数相加。</li><li>$a^{n} / a^{m} =  a^{n-m}$    同底数相除，底数不变，指数相减。</li><li>$(a^{n})^m = a^{am} $        底数的n次方的m次方，底数不变，指数相乘。</li><li>$(ab)^{n}=a^{n}\cdot b^{n}$    a乘b的n次方，等于a的n次方乘与b的n次方。</li></ul><h4 id="2-2-对数"><a href="#2-2-对数" class="headerlink" title="2.2. 对数"></a>2.2. 对数</h4><p>$ a^{x}=n$  如果a的x次方等于N（a&gt;0，且a不等于1），那么数x叫做以a为底N的对数（logarithm），记作$x=log_{a}N$。其中，a叫做对数的<a href="https://baike.baidu.com/item/底数/5416651" target="_blank" rel="noopener">底数</a>，N叫做<a href="https://baike.baidu.com/item/真数/326681" target="_blank" rel="noopener">真数</a>。《百度百科》</p><p><code>在计算机科学中，除非有特别的声明，否则所有的对数都是以2为底的。</code></p><p><strong>公式：</strong></p><ul><li>$logAB = logA+logB$  ;  A,B&gt;0 </li><li>$log_{A}B =\frac{log_{c}B}{log_{c}A}$   ;  A,B,C &gt; 0,  a≠1</li></ul><p>简单列了两个公式，大家看看就行了，知道一下啥是<code>对数</code>。</p><h3 id="3-时间复杂度"><a href="#3-时间复杂度" class="headerlink" title="3. 时间复杂度"></a>3. 时间复杂度</h3><p>对于算法<code>时间复杂度</code>，可能有的朋友可能想了，不就是估算一段代码的执行时间嘛，我们可以搞个监控啊，看看一下每个接口的耗时不就好了，何必那么麻烦，还要分析下时间复杂度。但是这个监控属于事后操作，只有代码在<code>运行时</code>，才能知道你写的代码<code>效率</code>高不高，那么如何在写代码的时候就评估一段代码的执行效率呢，这个时候就需要时间复杂度来分析了。大家平常写代码可以结合时间复杂度和监控做好<code>事前</code>、<code>事后</code>的分析，更好的优化代码。</p><p><code>时间复杂度是衡量算法的时间度量，用来评估一段代码的效率，记作：</code>$T(n) = O(f(n))$<code>,它表示随着问题规模n的增大，算法执行时间的增长率和</code>$f(n)$<code>相同。</code>$f(n)$<code>是语句所执行时间函数。</code></p><h4 id="3-1-大O表示法"><a href="#3-1-大O表示法" class="headerlink" title="3.1 大O表示法"></a>3.1 大O表示法</h4><p>因为渐进时间复杂度使用大写O来表示，所以也称<code>大O表示法</code>。例如: $O(f(n))$。</p><p><strong>常见时间复杂度：</strong></p><table><thead><tr><th align="center">复杂度</th><th align="center">非正式术语</th><th align="center">例子</th></tr></thead><tbody><tr><td align="center">$O(1)$</td><td align="center">常数阶</td><td align="center">$12$</td></tr><tr><td align="center">$O(logn)$</td><td align="center">对数阶</td><td align="center">$5log_{2}n+10$</td></tr><tr><td align="center">$O(n)$</td><td align="center">线性阶</td><td align="center">$2n+3$</td></tr><tr><td align="center">$O(nlogn)$</td><td align="center">nlogn阶</td><td align="center">$2n+3log_{2}n+2$</td></tr><tr><td align="center">$O(n^{2})$</td><td align="center">平方阶</td><td align="center">$3n^{2}$</td></tr><tr><td align="center">$O(n^{3})$</td><td align="center">立方阶</td><td align="center">$2n^{3}+5$</td></tr><tr><td align="center">$O(2^{n})$</td><td align="center">指数阶</td><td align="center">$2^{n}$</td></tr></tbody></table><p>常见时间复杂度所耗费时间从小到大依次是：</p><p>$O(1)$ &lt; $O(logn)$ &lt; $O(n)$ &lt; $O(nlogn)$ &lt; $O(n^{2})$ &lt; $O(n^{3})$ &lt; $O(2^{n})$</p><p><strong>推导大O的方法：</strong></p><ul><li>用1取代运行时间中的所有常数。例如：$O(2n^{2})$ ==&gt; $O(n^{2})$ </li><li>在函数中只保留最高阶项。例如 $O(2n^{2})+O(n)$ ==&gt; $O(2n^{2})$ </li><li>如果最高阶项存在并且不是1，则去掉与之相乘的系数。例如：$O(2n^{2})$ ==&gt; $O(n^{2})$ </li></ul><h4 id="3-2-如何分析时间复杂度"><a href="#3-2-如何分析时间复杂度" class="headerlink" title="3.2 如何分析时间复杂度"></a>3.2 如何分析时间复杂度</h4><ul><li><p>$O(1)$</p><pre><code>int i = 5;         /*执行一次*/int j = 6;         /*执行一次*/int sum = j + i;   /*执行一次*/</code></pre><p>这段代码的运行函数应该是$f(n)=3$ ,用来大O来表示的话应该是$O(f(n))=O(3)$ ,但是根据我们的推导大O表示法中的第一条，要用1代替函数中的常数，所以$O(3)=&gt;O(1)$,那么这段代码的时间复杂度就是$O(1)$而不是$O(3)$。</p></li><li><p>$O(logn)$</p><pre><code>int count = 1;             /*执行一次*/int n = 100;               /*执行一次*/while (count &lt; n) {    count = count * 2;     /*执行多次*/}</code></pre><p>这段代码为什么是logn呢？只有当count小于n的时候才会执行，并且每次count都乘以2，所以由$2^{x}=n$ 得知</p><p>$x=log_{2}n$ ,去掉底数所以这段代码的复杂性就是$O(logn)$ 。</p></li><li><p>$O(n)$ </p><pre><code>for (int k = 0; k &lt; n; k++) {    System.out.println(k);   /*执行n次*/}</code></pre><p>这段代码的执行次数会随着n的增大而增大，也就是说会执行n次，所以他的时间复杂度就是O(n)。</p></li><li><p>$O(n^{2})$ </p><pre><code>for (int k = 0; k &lt; n; k++) {   for (int l = 0; l &lt; n; l++) {      System.out.println(l);      /*执行了n*n次/   }}</code></pre><p>这段输出l的值得代码对于内循环来讲它执行了n次，但是每个内循环对于外循环来讲又被执行了n次，所以这个输出l值得代码就被执行了n乘n次，也就是$n^{2}$,所以这段代码的时间复杂度就是$O(n^{2})$ 。</p></li></ul><p><code>读到这里不知道大家学会了没有？其实分析一段代码的时间复杂度，就找到你代码中执行次数最多的地方，分析一下它的时间复杂度是什么，那么你整段代码的时间复杂度就是什么。以最大为准。</code></p><h4 id="3-3-时间复杂度量级"><a href="#3-3-时间复杂度量级" class="headerlink" title="3.3 时间复杂度量级"></a>3.3 时间复杂度量级</h4><pre><code>    public int find(int[] arrays, int findValue) {        int result = -1;                                /*执行一次*/        int n = arrays.length;        for (int i = 0; i &lt; n; i++) {            if (arrays[i] == findValue) {               /*执行arrays.length次*/                result = arrays[i];                break;            }        }        return result;                                 /*执行一次*/    }</code></pre><p>我们来分析一下上边这个方法，这个方法的作用是从一个数组中查找到它想要的值。其实一个算法的复杂度还会根据实际的执行情况有一定的变化，就比如上边这段代码，假如数组的长度是100，里面存的是1-100的数。</p><ul><li><p>最好情况时间复杂度</p><p>如果我在这个数组里面查找数字1，那么在它第一次遍历的时候就找到了这个值，然后就执行<code>break</code>结束当前循环，此时所有的代码只执行了一次，属于<code>常数阶</code>$O(1)$，这就是最好情况下这段代码的时间复杂度。</p></li><li><p>最坏情况时间复杂度</p><p>如果我在这个数组里面查找数字100，那么这个数组就要被遍历一边才能找到并返回，这样的话这个方法就要受到数组大小的影响了，如果数组的大小为n，那么就是n越大，执行次数越多。属于<code>线性阶</code>$O(n)$ ，这就是最坏情况下的时间复杂度。</p></li><li><p>平均情况时间复杂度</p><p>我们都知道最好、最坏时间复杂度都是在两种极端情况下的代码复杂度，发生的概率并不高，因次我们引入另一个概念<code>“平均时间复杂度”</code>。我们还看上边的这个方法，要查找个一个数有n+1中情况：在数组0 ~ n-1的的位置中和不再数组中，所以我们将所有代码的执行次数累加起来((1+2+3+…+n)+n),然后再除以所有情况n(n+1),就得到需要执行次数的平均值了。</p><p>$\frac{(1+2+3…+𝑛)+𝑛)}{(𝑛+1)} = \frac{𝑛(𝑛+3)}{2(𝑛+1)}$</p><p><strong>推导过程：</strong></p><p>🔥  $1+2+3…+𝑛=𝑛+(𝑛−1)+(𝑛−2)…+1$</p><p>🔥  $(1+2+3…+𝑛)=\frac {𝑛(1+𝑛)}{2}$</p><p>🔥  $(1+2+3…+𝑛)+𝑛= \frac {n(3+𝑛)}{2}$ </p><p>大O表示法，会<strong>省略系数、低阶、常量，</strong>所以平均情况时间复杂度是<strong>O(n)</strong>。</p></li></ul><p>  但是这个平均复杂度没有考虑各自情况的发生概率，这里的n+1个情况，它们的发生概率是不一样的，所以还需要引入各自情况发生的概率再具体分析。findValue要么在1<del>n中，要么不在1</del>n中，所以他们的概率都是$\frac{1}{2}$,同时数据在1<del>n中的各个位置的概率一样为$\frac{1}{n}$ ,根据概率乘法法则，findValue在1</del>n中的任意位置的概率是$\frac{1}{2n}$ ,因此在上边推导的基础上需要在加入概率的的发生情况。</p><p>  <strong>考虑概率的平均情况复杂度为：</strong></p><p>  $(1\frac{1}{2n}+2\frac{1}{2n}+3\frac{1}{2n}…+𝑛\frac{1}{2n})+𝑛\frac{1}{2}=\frac{3n+1}{4}$</p><p>  <strong>推导过程：</strong></p><p>  🔥  $(1+2+3…+𝑛)=\frac{𝑛(1+𝑛)}{2}$</p><p>  🔥 $(1\frac{1}{2n}+2\frac{1}{2n}+3\frac{1}{2n}…+𝑛\frac{1}{2n}))=\frac{1}{2n}(1+2+3…+𝑛)=\frac{1}{2n}∗\frac{𝑛(1+𝑛)}{2}=\frac{1+𝑛}{4}$</p><p>  🔥  $(1\frac{1}{2n}+2\frac{1}{2n}+3\frac{1}{2n}…+𝑛\frac{1}{2n}))+n\frac{1}{2}=\frac{1+𝑛}{4}+n\frac{1}{2}=\frac{3n+1}{4}$</p><p>  这就是概率论中的加权平均值，也叫做期望值，所以平均时间复杂度全称叫：<strong>加权平均时间复杂度</strong>或者<strong>期望时间复杂度</strong>。平均复杂度变为$O(\frac{3n+1}{4})$，忽略系数及常量后，最终得到加权平均时间复杂度为$O(n)$。</p><h3 id="4-空间复杂度"><a href="#4-空间复杂度" class="headerlink" title="4. 空间复杂度"></a>4. 空间复杂度</h3><p>算法的空间复杂度是对运行过程中临时占用存储空间大小的度量，算法空间复杂度的计算公式记作：$S(n) = O(f(n))$,n为问题规模，$f(n)$为语句关于n所占存储空间函数。由于空间复杂度和时间复杂度的大O表示法相同，所以我们就简单介绍下。</p><p>常见的空间复杂度从低到高是：</p><p>$O(1)$ &lt; $O(n)$ &lt; $O(n^{2})$ </p><h4 id="4-1-如何分析空间复杂度"><a href="#4-1-如何分析空间复杂度" class="headerlink" title="4.1 如何分析空间复杂度"></a>4.1 如何分析空间复杂度</h4><ul><li><p>$O(1)$</p><pre><code>public static void intFun(int n) {   var intValue = n;   //...}</code></pre><p>当算发的存储空间大小固定，和输入的规模没有直接的关系时，空间复杂度就记作O(1),就像上边这个方法，不管你是输入10，还是100，它占用的内存都是4字节。</p></li><li><p>$O(n)$</p><pre><code>public static void arrayFun(int n) {   var array = new int[n];   //...}</code></pre><p>当算法分配的空间是一个集合或者数组时，并且它的大小和输入规模n成正比时，此时空间复杂度记为$O(n)$。</p></li><li><p>$O(n^{2})$ </p><pre><code>public static void matrixFun(int n) {   var matrix = new int[n][n];   //...}</code></pre><p>当算法分配的空间是一个二维数组，并且它的第一维度和第二维度的大小都和输入规模n成正比时，此时空间复杂度记为$O(n^{2})$ 。</p></li></ul><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>对于<code>时间</code>和<code>空间</code>的取舍，我们就要根据具体的业务实际情况而定，有的时候就需要牺牲时间来换空间，有的时候就需要牺牲空间来换时间，在现在这个计算机硬件性能飙升的时代，当然我们还是喜欢选择牺牲空间来换时间，毕竟内存还是有的，也不贵。并且可以提高效率给用户更好的体验。</p><ul><li><p>什么是时间复杂度？</p><p>时间复杂度就是对算法运行时间长短的度量，用大O表示为$T(n) = O(f(n))$ 。常见的时间复杂度从低到高的顺序是：$O(1)$、$O(logn)$ 、$O(n)$、$O(nlogn)$、$O(n^{2})$ 。</p></li><li><p>什么是空间复杂度？</p><p>空间复杂度是对算法运行时所占用的临时存储空间的度量，用大O标识为$S(n)= O(f(n))$ 。常见的空间复杂度从低到高的顺序是：$O(1)$ 、$O(n)$、$O(n^{2})$ 。</p></li></ul><h3 id="6-参考"><a href="#6-参考" class="headerlink" title="6. 参考"></a>6. 参考</h3><ol><li>《数据结构与算法分析》</li><li>《大话数据结构》</li><li>《漫画算法》</li></ol><blockquote><p>能看到这里的朋友，相信你也对学习保持着一定的热情，觉得对你有帮助的话麻烦点个赞或在看以资鼓励吧，有什么问题欢迎留言或者关注我公众号进群交流。另外文章有理解错误、写错、说错的地方，希望大家指正，这是对我最大的帮助，谢谢大家。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通用点赞设计思路</title>
      <link href="/2019/11/08/tong-yong-dian-zan-she-ji-si-lu/"/>
      <url>/2019/11/08/tong-yong-dian-zan-she-ji-si-lu/</url>
      
        <content type="html"><![CDATA[<p>点赞作为一个高频率的操作，如果每次操作都读写数据库会增加数据库的压力，所以采用缓存+定时任务来实现。点赞数据是在redis中缓存半小时，同时定时任务是每隔5分钟执行一次，做持久化存储，这里的缓存时间和任务执行时间可根据项目情况而定。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1.降低对数据库的影响<br>2.提高点赞的效率</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>1.如果任务挂了，会丢失点赞数据<br>2.持久化存储不是实时的</p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="https://user-gold-cdn.xitu.io/2018/11/26/1674e3856a21faac?w=1155&h=1487&f=png&s=123171" alt="在这里插入图片描述"></p><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><pre><code>create table user_like(id bigint(20) unsigned not null auto_increment comment &#39;id&#39;,user_id bigint(20) not null default 0 comment &#39;用户id&#39;,liked_id varchar(21) not null default &#39;&#39; comment &#39;被点赞的id&#39;,liked_status int(11) not null default 0 comment &#39;点赞状态，0未点赞，1已点赞&#39;,liked_type int(11) not null default 0 comment &#39;点赞的类型&#39;,liked_time timestamp not null default &#39;0000-00-00 00:00:00.000000&#39; comment &#39;点赞时间&#39;, is_delete tinyint not null default &#39;0&#39; comment &#39;是否逻辑删除&#39;, create_time timestamp not null default CURRENT_TIMESTAMP comment &#39;创建时间&#39;, update_time timestamp not null default CURRENT_TIMESTAMP on update CURRENT_TIMESTAMP comment &#39;更新时间&#39;, primary key (id), unique uniq_user_id_liked_id_type(user_id,liked_id,liked_type), key idx_liked_id (liked_id), key idx_create_time (create_time), key idx_update_time (update_time))ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 ROW_FORMAT=COMPACT COMMENT=&#39;用户点赞表&#39;;create table user_like_stat(id bigint(20) unsigned not null auto_increment comment &#39;id&#39;,liked_id varchar(21) not null default &#39;&#39; comment &#39;被点赞id&#39;,liked_count int(11) not null default 0 comment &#39;点赞总数量&#39;, is_delete tinyint not null default &#39;0&#39; comment &#39;是否逻辑删除&#39;, create_time timestamp not null default CURRENT_TIMESTAMP comment &#39;创建时间&#39;, update_time timestamp not null default CURRENT_TIMESTAMP on update CURRENT_TIMESTAMP comment &#39;更新时间&#39;, primary key (id), unique uniq_info_num(liked_id), key idx_create_time (create_time), key idx_update_time (update_time))ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 ROW_FORMAT=COMPACT COMMENT=&#39;点赞统计表&#39;;</code></pre><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><h4 id="1-设计缓存数据格式"><a href="#1-设计缓存数据格式" class="headerlink" title="1.设计缓存数据格式"></a>1.设计缓存数据格式</h4><p>整个点赞模块主要采用缓存来完成，所以要选择合适数据结构，我选择hash数据结构来实现，应为它可以添加、获取、移除单个键值对，并且可以获取所有键值对。主要缓存两种数据，一种是用户的点赞状态，一种是被点赞id的点赞数量。这两种数据分别用两个key存储，这两个key中都是存储的多个键值对。键值对格式如下：</p><p>用户的点赞状态key-value——&gt;{“被点赞的id::用户id” :”点赞状态::点赞时间::点赞类型”}</p><p>被点赞id的点赞数量key-value——&gt;{“被点赞id” : “点赞数量”}</p><h4 id="2-大key拆分"><a href="#2-大key拆分" class="headerlink" title="2.大key拆分"></a>2.大key拆分</h4><p>点赞的数据量比较大的情况下，上面的设计会造成单个key存储的value很大，由于redis是单线程运行，如果一次操作的value很大，会对整个redis的响应时间有影响，所以我们这里在将上面的两个key做拆分。固定key的数量，每次存取时都先在本地计算出落在了哪个key上，这个操作就类似于redis分区、分片。有利于降低单次操作的压力，将压力平分到多个key上。</p><pre><code>//点赞状态key拆分newHashKey  =  hashKey +&quot;_&quot;+ (userId% 5);   hset (newHashKey, field, value) ;  hget(newHashKey, field)//点赞数量key拆分newHashKey  =  hashKey +&quot;_&quot;+ Math.abs((hash*(被点赞id)) % 5);   hset (newHashKey, field, value) ;  hget(newHashKey, field)</code></pre><h4 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h4><p>以下值截取了部分代码,提供思路。</p><p>1.点赞状态枚举<br><img src="https://user-gold-cdn.xitu.io/2018/11/26/1674e3856a41d9fa?w=1170&h=988&f=png&s=949175" alt="在这里插入图片描述"><br>2.点赞类型枚举<br><img src="https://user-gold-cdn.xitu.io/2018/11/26/1674e3856a3a702f?w=1132&h=1012&f=png&s=941416" alt="在这里插入图片描述"><br> 3.用户点赞类<br> <img src="https://user-gold-cdn.xitu.io/2018/11/26/1674e3856a408f69?w=638&h=926&f=png&s=504060" alt="在这里插入图片描述"><br>4.点赞接口实现<br>这里使用策略设计模式来实现，方便以后的扩展，对这个设计模式不了解的请点击</p><p><a href="https://juejin.im/post/5bdc1e77e51d4502b064e893" target="_blank" rel="noopener">https://juejin.im/post/5bdc1e77e51d4502b064e893</a></p><p><img src="https://user-gold-cdn.xitu.io/2018/11/26/1674e3856aba32a9?w=1364&h=588&f=png&s=733563" alt="这里进行策略的选择"><img src="https://user-gold-cdn.xitu.io/2018/11/26/1674e3856ada39d1?w=1222&h=630&f=png&s=695643" alt="在这里插入图片描述"><img src="https://user-gold-cdn.xitu.io/2018/11/26/1674e38598e76d58?w=1146&h=430&f=png&s=412751" alt="在这里插入图片描述"><br>5.逻辑<br>取消点赞和这个接口相同，只需要替换下点赞状态和redis增量<br><img src="https://user-gold-cdn.xitu.io/2018/11/26/1674e38599e90563?w=1830&h=1112&f=png&s=1588595" alt="在这里插入图片描述"><br>6.定时任务<br>定时任务采用Azkaban任务调度系统，每个5分种运行一次任务，把点赞数据从redis缓存中取出做持久化到mysql。</p><h4 id="4-改进点"><a href="#4-改进点" class="headerlink" title="4.改进点"></a>4.改进点</h4><p>现在的读取都是用的一个key，接下来可以优化为把key做读写分离。写入和读取分别用不同的key，这样做可以减少资源的浪费，要不每次跑定时任务都会把已经持久化并且缓存未失效的数据拿出来做一遍查询。</p><p>以上就是点赞的一个实现思路，大家有什么更好的方法或者改进的点，欢迎提出来。</p><blockquote><p>感谢大家的观看，希望多多关注哦。 如有错误，烦请指正。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Java8系列」NPE神器 Optional</title>
      <link href="/2019/11/06/java8-xi-lie-npe-shen-qi-optional/"/>
      <url>/2019/11/06/java8-xi-lie-npe-shen-qi-optional/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5d2d15825188253d7201d297" target="_blank" rel="noopener">「Java8系列」神秘的Lambda</a><br><br><a href="https://juejin.im/post/5d2ff837f265da1bd424b710" target="_blank" rel="noopener">「Java8系列」神奇的函数式接口</a><br><br><a href="https://juejin.im/post/5d37bbd451882551c37fbc04" target="_blank" rel="noopener">「Java8系列」流式编程Stream</a></p><h4 id="Optional类入门"><a href="#Optional类入门" class="headerlink" title="Optional类入门"></a>Optional类入门</h4><p>Optional<code>&lt;T&gt;</code> 类(java.util.Optional) 是一个容器类，代表一个值存在或不存在，原来用 null 表示一个值不存在，现在Optional可以更好的表达这个概念。并且可以避免空指针异常。你可以把Optional对象看成一种特殊的集合数据，它至多包含一个元素。</p><p><strong>常用方法</strong>:</p><ul><li>Optional.of(T t) : 将指定值用 Optional 封装之后返回，如果该值为 null，则抛出一个 NullPointerException 异常。</li><li>Optional.empty() : 创建一个空的 Optional 实例。</li><li>Optional.ofNullable(T t) : 将指定值用 Optional 封装之后返回，如果该值为 null，则返回一个空的 Optional 对象。</li><li>get() : 如果该值存在，将该值用 Optional 封装返回，否则抛出一个 NoSuchElementException 异常。</li><li>orElse(T t) : 如果调用对象包含值，返回该值，否则返回t。</li><li>orElseGet(Supplier s) : 如果调用对象包含值，返回该值，否则返回 s 获取的值。</li><li>orElseThrow() ：它会在对象为空的时候抛出异常。</li><li>map(Function f) : 如果值存在，就对该值执行提供的 mapping 函数调用。</li><li>flatMap(Function mapper) : 如果值存在，就对该值执行提供的mapping 函数调用，返回一个 Optional 类型的值，否则就返回一个空的 Optional 对象。</li></ul><p><code>注意：Optional类的设计初衷仅仅是要支持能返回Optional对象的语法，并未考虑作为类的字段使用，也没有实现序列化接口，在领域模型中使用Optional，有可能引发程序故障。</code></p><h4 id="使用Optional实战"><a href="#使用Optional实战" class="headerlink" title="使用Optional实战"></a>使用Optional实战</h4><p>用Optional封装可能为null的值，我们在项目中很多时候都会遇到，掉一个方法然后返回一个null，最后需要不断的判空。比如获取Map中的不含指定键的值，它的get方法返回的就是一个null。</p><pre><code> //例如： Object value = map.get(&quot;key&quot;); //使用Optional封装结果后可以这么写： Optional&lt;Object&gt; value = Optional.ofNullable(map.get(&quot;key&quot;)); /** * 如果想在获取为null以后给个默认值，可以这么写： * orElse和orElseGet的区别是当Optional的值是空值时，无论orElse还是orElseGet都会执行；而当返回的Optional有值时，orElse会执行，而orElseGet不会执行。 */ Object value = Optional.ofNullable(map.get(&quot;key&quot;)).orElse(&quot;value&quot;); Object value1 = Optional.ofNullable(map.get(&quot;key&quot;)).orElseGet(()-&gt;&quot;value&quot;);</code></pre><p> 由于某种原因，函数无法返回某个值，这时除了返回null，Java API比较常见的替代做法是抛出一个异常。这种情况比较典型的例子是使用静态方法Integer.parseInt(String)，将String转换为int。在这个例子中，如果String无法解析到对应的整型，该方法就抛出一个NumberFormatException。最后的效果是，发生String无法转换为int时，代码发出一个遭遇非法参数的信号，唯一的不同是，这次你需要使用try/catch 语句，而不是使用if条件判断来控制一个变量的值是否非空。</p><p>你也可以用空的Optional对象，对遭遇无法转换的String时返回的非法值进行建模，这时你期望parseInt的返回值是一个optional。我们无法修改最初的Java方法，但是这无碍我们进 行需要的改进，你可以实现一个工具方法，将这部分逻辑封装于其中，最终返回一个我们希望的 Optional对象，代码如下所示。</p><pre><code>public static Optional&lt;Integer&gt; stringToInt(String s) {try {         //如果String能转换为对应的Integer，将其封装在Optioal对象中返回        return Optional.of(Integer.parseInt(s));    } catch (NumberFormatException e) {        //否则返回一个空的Optional对象        return Optional.empty();    }}</code></pre><p>Optional就是讲到这里，这个实在没什么好说的了，大家自己实践吧。</p><blockquote><p>感谢大家的观看，希望多多关注哦。 如有错误，烦请指正。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>赶快看看Java11，不然你就out了</title>
      <link href="/2019/11/05/gan-kuai-kan-kan-java11-bu-ran-ni-jiu-out-liao/"/>
      <url>/2019/11/05/gan-kuai-kan-kan-java11-bu-ran-ni-jiu-out-liao/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么选择Java11"><a href="#为什么选择Java11" class="headerlink" title="为什么选择Java11"></a>为什么选择Java11</h3><ul><li>容器环境支持，GC等领域的增强。</li><li>进行了瘦身，更轻量级，安装包体积小。</li><li>JDK11 是一个长期支持版。</li></ul><h3 id="特性介绍"><a href="#特性介绍" class="headerlink" title="特性介绍"></a>特性介绍</h3><p>由于直接从Java8跨越到Java11，所以特性介绍就把Java9-Java11的部分特性一起介绍一下。想要了解Java8特性的朋友可以去我的博客找「Java8系列」。</p><h4 id="Jshell-since-9"><a href="#Jshell-since-9" class="headerlink" title="Jshell  @since 9"></a>Jshell  @since 9</h4><p>Jshell在Java9中就被提出来了，可以直接在终端写Java程序，回车就可以执行。Jshell默认会导入下面的一些包,所以在Jshell环境中这些包的内容都是可以使用的。</p><pre><code>import java.lang.*;import java.io.*;import java.math.*;import java.net.*;import java.nio.file.*;import java.util.*;import java.util.concurrent.*;import java.util.function.*;import java.util.prefs.*;import java.util.regex.*;import java.util.stream.*;</code></pre><h5 id="1-什么是Jshell"><a href="#1-什么是Jshell" class="headerlink" title="1.什么是Jshell?"></a>1.什么是Jshell?</h5><p>Jshell是在 Java 9 中引入的。它提供了一个交互式 shell，用于快速原型、调试、学习 Java 及 Java API，所有这些都不需要 public static void main 方法，也不需要在执行之前编译代码。</p><h5 id="2-Jshell的使用"><a href="#2-Jshell的使用" class="headerlink" title="2.Jshell的使用"></a>2.Jshell的使用</h5><p>打开终端，键入jshell进入jshell环境，然后输入/help intro可以查看Jshell的介绍。</p><pre><code> lixiaoshuang@localhost  ~  jshell|  欢迎使用 JShell -- 版本 11.0.2|  要大致了解该版本, 请键入: /help introjshell&gt; /help intro||                                   intro|                                   =====||  使用 jshell 工具可以执行 Java 代码，从而立即获取结果。|  您可以输入 Java 定义（变量、方法、类等等），例如：int x = 8|  或 Java 表达式，例如：x + x|  或 Java 语句或导入。|  这些小块的 Java 代码称为“片段”。||  这些 jshell 工具命令还可以让您了解和|  控制您正在执行的操作，例如：/list||  有关命令的列表，请执行：/helpjshell&gt;</code></pre><p>Jshell确实是一个好用的小工具，这里不做过多介绍，我就举一个例子，剩下的大家自己体会。比如我们现在就想随机生成一个UUID，以前需要这么做：</p><ul><li>创建一个类。</li><li>创建一个main方法。</li><li>然后写一个生成UUID的逻辑，执行。</li></ul><p>现在只需要,进入打开终端键入jshell,然后直接输入<code>var uuid = UUID.randomUUID()</code>回车。就可以看到uuid的回显，这样我们就得到了一个uuid。并不需要public static void main;</p><pre><code> lixiaoshuang@localhost  ~  jshell|  欢迎使用 JShell -- 版本 11.0.2|  要大致了解该版本, 请键入: /help introjshell&gt; var uuid = UUID.randomUUID(); uuid ==&gt; 9dac239e-c572-494f-b06d-84576212e012jshell&gt;</code></pre><h5 id="3-怎么退出Jshell？"><a href="#3-怎么退出Jshell？" class="headerlink" title="3.怎么退出Jshell？"></a>3.怎么退出Jshell？</h5><p>在Jshell环境中键入<code>/exit</code>就可以退出。</p><pre><code> lixiaoshuang@localhost  ~  lixiaoshuang@localhost  ~  jshell|  欢迎使用 JShell -- 版本 11.0.2|  要大致了解该版本, 请键入: /help introjshell&gt; var uuid = UUID.randomUUID();uuid ==&gt; 9dac239e-c572-494f-b06d-84576212e012jshell&gt; /exit|  再见 lixiaoshuang@localhost  ~ </code></pre><h4 id="模块化（Module）-since-9"><a href="#模块化（Module）-since-9" class="headerlink" title="模块化（Module）@since 9"></a>模块化（Module）@since 9</h4><h5 id="1-什么是模块化？"><a href="#1-什么是模块化？" class="headerlink" title="1.什么是模块化？"></a>1.什么是模块化？</h5><p>模块化就是增加了更高级别的聚合，是Package的封装体。Package是一些类路径名字的约定，而模块是一个或多个Package组成的封装体。</p><p>java9以前 ：package =&gt; class/interface。</p><p>java9以后 ：module =&gt; package =&gt; class/interface。</p><p>那么JDK被拆为了哪些模块呢？打开终端执行<code>java --list-modules</code>查看。</p><pre><code>lixiaoshuang@localhost  ~ java --list-modulesjava.base@11.0.2java.compiler@11.0.2java.datatransfer@11.0.2java.desktop@11.0.2java.instrument@11.0.2java.logging@11.0.2java.management@11.0.2java.management.rmi@11.0.2java.naming@11.0.2java.net.http@11.0.2java.prefs@11.0.2java.rmi@11.0.2java.scripting@11.0.2java.se@11.0.2java.security.jgss@11.0.2java.security.sasl@11.0.2java.smartcardio@11.0.2java.sql@11.0.2java.sql.rowset@11.0.2java.transaction.xa@11.0.2java.xml@11.0.2java.xml.crypto@11.0.2jdk.accessibility@11.0.2jdk.aot@11.0.2jdk.attach@11.0.2jdk.charsets@11.0.2jdk.compiler@11.0.2jdk.crypto.cryptoki@11.0.2jdk.crypto.ec@11.0.2jdk.dynalink@11.0.2jdk.editpad@11.0.2jdk.hotspot.agent@11.0.2jdk.httpserver@11.0.2jdk.internal.ed@11.0.2jdk.internal.jvmstat@11.0.2jdk.internal.le@11.0.2jdk.internal.opt@11.0.2jdk.internal.vm.ci@11.0.2jdk.internal.vm.compiler@11.0.2jdk.internal.vm.compiler.management@11.0.2jdk.jartool@11.0.2jdk.javadoc@11.0.2jdk.jcmd@11.0.2jdk.jconsole@11.0.2jdk.jdeps@11.0.2jdk.jdi@11.0.2jdk.jdwp.agent@11.0.2jdk.jfr@11.0.2jdk.jlink@11.0.2jdk.jshell@11.0.2jdk.jsobject@11.0.2jdk.jstatd@11.0.2jdk.localedata@11.0.2jdk.management@11.0.2jdk.management.agent@11.0.2jdk.management.jfr@11.0.2jdk.naming.dns@11.0.2jdk.naming.rmi@11.0.2jdk.net@11.0.2jdk.pack@11.0.2jdk.rmic@11.0.2jdk.scripting.nashorn@11.0.2jdk.scripting.nashorn.shell@11.0.2jdk.sctp@11.0.2jdk.security.auth@11.0.2jdk.security.jgss@11.0.2jdk.unsupported@11.0.2jdk.unsupported.desktop@11.0.2jdk.xml.dom@11.0.2jdk.zipfs@11.0.2</code></pre><h5 id="2-为什么这么做？"><a href="#2-为什么这么做？" class="headerlink" title="2.为什么这么做？"></a>2.为什么这么做？</h5><p>大家都知道JRE中有一个超级大的rt.jar(60多M)，tools.jar也有几十兆，以前运行一个hello world也需要上百兆的环境。</p><ul><li>让Java SE程序更加容易轻量级部署。</li><li>强大的封装能力。</li><li>改进组件间的依赖管理，引入比jar粒度更大的Module。</li><li>改进性能和安全性。</li></ul><h5 id="3-怎么定义模块"><a href="#3-怎么定义模块" class="headerlink" title="3.怎么定义模块?"></a>3.怎么定义模块?</h5><p>模块的是通过module-info.java进行定义，编译后打包后，就成为一个模块的实体。下面来看下最简单的模块定义。</p><p><img src="https://i.loli.net/2019/11/03/eaJ9cAKDjTWipo8.png" alt></p><p><img src="https://i.loli.net/2019/11/03/FKVhUwTfy4AraqP.png" alt></p><h5 id="4-模块的关键字"><a href="#4-模块的关键字" class="headerlink" title="4.模块的关键字"></a>4.模块的关键字</h5><ul><li><p>open</p><p>用来指定开放模块,开放模块的所有包都是公开的,public的可以直接引用使用,其他类型可以通过反射得到。</p><pre><code>open module module.one {    //导入日志包   requires java.logging;}</code></pre></li><li><p>opens</p><p>opens 用来指定开放的包,其中public类型是可以直接访问的,其他类型可以通过反射得到。</p><pre><code>module module.one {    opens &lt;package&gt;;}</code></pre></li><li><p>exports</p><p>exports用于指定模块下的哪些包可以被其他模块访问。</p><pre><code>module module.one {    exports &lt;package&gt;;    exports &lt;package&gt; to &lt;module1&gt;, &lt;module2&gt;...;}</code></pre></li><li><p>requires</p><p>该关键字声明当前模块与另一个模块的依赖关系。</p><pre><code>module module.one {    requires &lt;package&gt;;}</code></pre></li><li><p>uses、provides…with…</p><p>uses语句使用服务接口的名字,当前模块就会发现它,使用java.util.ServiceLoader类进行加载,必须是本模块中的,不能是其他模块中的.其实现类可以由其他模块提供。</p><pre><code>module module.one {    //对外提供的接口服务 ,下面指定的接口以及提供服务的impl，如果有多个实现类，用用逗号隔开    uses &lt;接口名&gt;;    provides &lt;接口名&gt; with &lt;接口实现类&gt;,&lt;接口实现类&gt;;}</code></pre></li></ul><h4 id="var关键字-since-10"><a href="#var关键字-since-10" class="headerlink" title="var关键字   @since 10"></a>var关键字   @since 10</h4><h5 id="1-var是什么？"><a href="#1-var是什么？" class="headerlink" title="1.var是什么？"></a>1.var是什么？</h5><p>var是Java10中新增的局部类型变量推断。它会根据后面的值来推断变量的类型，所以var必须要初始化。</p><p>例：</p><pre><code>var a;       ❌var a = 1;   ✅</code></pre><h5 id="2-var使用示例"><a href="#2-var使用示例" class="headerlink" title="2.var使用示例"></a>2.var使用示例</h5><ul><li><p>var定义局部变量</p><pre><code>var a = 1; 等于int a = 1;</code></pre></li><li><p>var接收方法返回时</p><pre><code>var result = this.getResult();等于String result = this.getResult();</code></pre></li><li><p>var循环中定义局部变量</p><pre><code>for (var i = 0; i &lt; 5; i++) {   System.out.println(i);}等于for (int i = 0; i &lt; 5; i++) {   System.out.println(i);}</code></pre></li><li><p>var结合泛型</p><pre><code>var list1 = new ArrayList&lt;String&gt;();  //在&lt;&gt;中指定了list类型为String等于List&lt;String&gt; list1 = new ArrayList&lt;&gt;();var list2 = new ArrayList&lt;&gt;();        //&lt;&gt;里默认会是Object</code></pre></li><li><p>var在Lambda中使用（java11才可以使用）</p><pre><code>Consumer&lt;String&gt; Consumer = (var i) -&gt; System.out.println(i);等于Consumer&lt;String&gt; Consumer = (String i) -&gt; System.out.println(i);</code></pre></li></ul><h5 id="3-var不能再哪里使用？"><a href="#3-var不能再哪里使用？" class="headerlink" title="3.var不能再哪里使用？"></a>3.var不能再哪里使用？</h5><ul><li>类成员变量类型。</li><li>方法返回值类型。</li><li>Java10中Lambda不能使用var，Java11中可以使用。</li></ul><h4 id="增强api"><a href="#增强api" class="headerlink" title="增强api"></a>增强api</h4><h5 id="1-字符串增强-since-11"><a href="#1-字符串增强-since-11" class="headerlink" title="1.字符串增强 @since 11"></a>1.字符串增强 @since 11</h5><pre><code>// 判断字符串是否为空白&quot; &quot;.isBlank();                     // true// 去除首尾空格&quot; Hello Java11 &quot;.strip();          // &quot;Hello Java11&quot;// 去除尾部空格 &quot; Hello Java11 &quot;.stripTrailing();  // &quot; Hello Java11&quot;// 去除首部空格 &quot; Hello Java11 &quot;.stripLeading();   // &quot;Hello Java11 &quot;// 复制字符串&quot;Java11&quot;.repeat(3);                // &quot;Java11Java11Java11&quot;// 行数统计&quot;A\nB\nC&quot;.lines().count();         // 3</code></pre><h5 id="2-集合增强"><a href="#2-集合增强" class="headerlink" title="2.集合增强"></a>2.集合增强</h5><p>从Java 9 开始，jdk里面就为集合（List、Set、Map）增加了of和copyOf方法。它们用来创建不可变集合。</p><ul><li>of()  @since 9</li><li>copyOf()  @since 10</li></ul><p>示例一：</p><pre><code>        var list = List.of(&quot;Java&quot;, &quot;Python&quot;, &quot;C&quot;); //不可变集合        var copy = List.copyOf(list);         //copyOf判断是否是不可变集合类型，如果是直接返回        System.out.println(list == copy);    // true        var list = new ArrayList&lt;String&gt;();  // 这里返回正常的集合        var copy = List.copyOf(list);        // 这里返回一个不可变集合        System.out.println(list == copy);    // false</code></pre><p>示例二：</p><pre><code>        var set = Set.of(&quot;Java&quot;, &quot;Python&quot;, &quot;C&quot;);        var copy = Set.copyOf(set);        System.out.println(set == copy);     // true        var set1 = new HashSet&lt;String&gt;();        var copy1 = List.copyOf(set1);        System.out.println(set1 == copy1);   // false</code></pre><p>示例三：</p><pre><code>        var map = Map.of(&quot;Java&quot;, 1, &quot;Python&quot;, 2, &quot;C&quot;, 3);        var copy = Map.copyOf(map);        System.out.println(map == copy);     // true        var map1 = new HashMap&lt;String, Integer&gt;();        var copy1 = Map.copyOf(map1);        System.out.println(map1 == copy1);   // false</code></pre><p><code>注意：使用 of 和 copyOf 创建的集合为不可变集合，不能进行添加、删除、替换、排序等操作，不然会报java.lang.UnsupportedOperationException异常，使用Set.of()不能出现重复元素、Map.of()不能出现重复key，否则回报java.lang.IllegalArgumentException。</code>。</p><h5 id="3-Stream增强-since-9"><a href="#3-Stream增强-since-9" class="headerlink" title="3.Stream增强 @since 9"></a>3.Stream增强 @since 9</h5><p>Stream是Java 8 中的特性，在Java 9 中为其新增了4个方法：</p><ul><li><p>ofNullable(T t)</p><p>此方法可以接收null来创建一个空流</p><pre><code>以前Stream.of(null);  //报错现在Stream.ofNullable(null);</code></pre></li><li><p>takeWhile(Predicate&lt;? super T&gt; predicate) </p><p>此方法根据Predicate接口来判断如果为true就 <code>取出</code> 来生成一个新的流,只要碰到false就终止，不管后边的元素是否符合条件。</p><pre><code>        Stream&lt;Integer&gt; integerStream = Stream.of(6, 10, 11, 15, 20);        Stream&lt;Integer&gt; takeWhile = integerStream.takeWhile(t -&gt; t % 2 == 0);        takeWhile.forEach(System.out::println);   // 6,10</code></pre></li><li><p>dropWhile(Predicate&lt;? super T&gt; predicate)</p><p>此方法根据Predicate接口来判断如果为true就 <code>丢弃</code> 来生成一个新的流,只要碰到false就终止，不管后边的元素是否符合条件。</p><pre><code>        Stream&lt;Integer&gt; integerStream = Stream.of(6, 10, 11, 15, 20);        Stream&lt;Integer&gt; takeWhile = integerStream.dropWhile(t -&gt; t % 2 == 0);        takeWhile.forEach(System.out::println);  //11,15,20</code></pre></li><li><p>iterate重载</p><p>以前使用iterate方法生成无限流需要配合limit进行截断</p><pre><code>        Stream&lt;Integer&gt; limit = Stream.iterate(1, i -&gt; i + 1).limit(5);        limit.forEach(System.out::println);   //1,2,3,4,5</code></pre><p>现在重载后这个方法增加了个判断参数</p><pre><code>        Stream&lt;Integer&gt; iterate = Stream.iterate(1, i -&gt; i &lt;= 5, i -&gt; i + 1);        iterate.forEach(System.out::println);  //1,2,3,4,5</code></pre></li></ul><h5 id="4-Optional增强-since-9"><a href="#4-Optional增强-since-9" class="headerlink" title="4.Optional增强  @since 9"></a>4.Optional增强  @since 9</h5><ul><li><p>stream()</p><p>如果为空返回一个空流，如果不为空将Optional的值转成一个流。</p><pre><code>        //返回Optional值的流        Stream&lt;String&gt; stream = Optional.of(&quot;Java 11&quot;).stream();        stream.forEach(System.out::println);    // Java 11        //返回空流        Stream&lt;Object&gt; stream = Optional.ofNullable(null).stream();        stream.forEach(System.out::println);    // </code></pre></li></ul><ul><li><p>ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction)</p><p>个人感觉这个方法就是结合isPresent()对Else的增强，ifPresentOrElse 方法的用途是，如果一个 Optional 包含值，则对其包含的值调用函数 action，即 action.accept(value)，这与 ifPresent 一致；与 ifPresent 方法的区别在于，ifPresentOrElse 还有第二个参数 emptyAction —— 如果 Optional 不包含值，那么 ifPresentOrElse 便会调用 emptyAction，即 emptyAction.run()。</p><pre><code>        Optional&lt;Integer&gt; optional = Optional.of(1);        optional.ifPresentOrElse( x -&gt; System.out.println(&quot;Value: &quot; + x),() -&gt;                System.out.println(&quot;Not Present.&quot;));    //Value: 1        optional = Optional.empty();        optional.ifPresentOrElse( x -&gt; System.out.println(&quot;Value: &quot; + x),() -&gt;                System.out.println(&quot;Not Present.&quot;));    //Not Present.</code></pre></li><li><p>or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)</p><pre><code>       Optional&lt;String&gt; optional1 = Optional.of(&quot;Java&quot;);       Supplier&lt;Optional&lt;String&gt;&gt; supplierString = () -&gt; Optional.of(&quot;Not Present&quot;);       optional1 = optional1.or( supplierString);       optional1.ifPresent( x -&gt; System.out.println(&quot;Value: &quot; + x));  //Value: Java       optional1 = Optional.empty();       optional1 = optional1.or( supplierString);       optional1.ifPresent( x -&gt; System.out.println(&quot;Value: &quot; + x)); //Value: Not Present</code></pre></li></ul><h5 id="5-InputStream增强-since-9"><a href="#5-InputStream增强-since-9" class="headerlink" title="5.InputStream增强  @since 9"></a>5.InputStream增强  @since 9</h5><pre><code>        String lxs = &quot;java&quot;;        try (var inputStream = new ByteArrayInputStream(lxs.getBytes());             var outputStream = new ByteArrayOutputStream()) {            inputStream.transferTo(outputStream);            System.out.println(outputStream);    //java        }</code></pre><h4 id="HTTP-Client-API"><a href="#HTTP-Client-API" class="headerlink" title="HTTP Client API"></a>HTTP Client API</h4><p>改api支持同步和异步两种方式，下面是两种方式的示例：</p><pre><code>        var request = HttpRequest.newBuilder()                .uri(URI.create(&quot;https://www.baidu.com/&quot;))                .build();        var client = HttpClient.newHttpClient();        // 同步        HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());        System.out.println(response.body());        // 异步        CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; sendAsync = client.sendAsync(request, HttpResponse.BodyHandlers.ofString());        //这里会阻塞        HttpResponse&lt;String&gt; response1 = sendAsync.get();        System.out.println(response1.body());</code></pre><h4 id="直接运行java文件"><a href="#直接运行java文件" class="headerlink" title="直接运行java文件"></a>直接运行java文件</h4><p>我们都知道以前要运行一个.java文件，首先要javac编译成.class文件，然后在java执行：</p><pre><code>//编译javac Java11.java//运行java Java11</code></pre><p>在java11中，只需要通过java一个命令就可以搞定</p><pre><code>java Java11.java</code></pre><h3 id="移除内容"><a href="#移除内容" class="headerlink" title="移除内容"></a>移除内容</h3><ul><li>com.sun.awt.AWTUtilities。</li><li>sun.misc.Unsafe.defineClass   使用java.lang.invoke.MethodHandles.Lookup.defineClass来替代。</li><li>Thread.destroy() 以及 Thread.stop(Throwable) 方法。</li><li>sun.nio.ch.disableSystemWideOverlappingFileLockCheck 属性。</li><li>sun.locale.formatasdefault 属性。</li><li>jdk snmp 模块。</li><li>javafx，openjdk 是从java10版本就移除了，oracle java10还尚未移除javafx ，而java11版本将javafx也移除了。</li><li>Java Mission Control，从JDK中移除之后，需要自己单独下载。</li><li>Root Certificates ：Baltimore Cybertrust Code Signing CA，SECOM ，AOL and Swisscom。</li><li>在java11中将java9标记废弃的Java EE及CORBA模块移除掉。</li></ul><h3 id="完全支持Linux容器（包括docker）"><a href="#完全支持Linux容器（包括docker）" class="headerlink" title="完全支持Linux容器（包括docker）"></a>完全支持Linux容器（包括docker）</h3><p>许多运行在Java虚拟机中的应用程序（包括Apache Spark和Kafka等数据服务以及传统的企业应用程序）都可以在Docker容器中运行。但是在Docker容器中运行Java应用程序一直存在一个问题，那就是在容器中运行JVM程序在设置内存大小和CPU使用率后，会导致应用程序的性能下降。这是因为Java应用程序没有意识到它正在容器中运行。随着Java 10的发布，这个问题总算得以解决，JVM现在可以识别由容器控制组（cgroups）设置的约束。可以在容器中使用内存和CPU约束来直接管理Java应用程序，其中包括：</p><ul><li>遵守容器中设置的内存限制</li><li>在容器中设置可用的CPU</li><li>在容器中设置CPU约束</li></ul><p><code>Java 10的这个改进在Docker for Mac、Docker for Windows以及Docker Enterprise Edition等环境均有效。</code></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> <img src="https://i.loli.net/2019/11/05/uesYIQnMUgOdJpN.png" alt="Java版本特性.png"></p><blockquote><p>感谢大家的观看，希望多多关注哦。 如有错误，烦请指正。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Java8系列」流式编程Stream</title>
      <link href="/2019/11/04/java8-xi-lie-liu-shi-bian-cheng-stream/"/>
      <url>/2019/11/04/java8-xi-lie-liu-shi-bian-cheng-stream/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><a href="https://juejin.im/post/5d2d15825188253d7201d297" target="_blank" rel="noopener">「Java8系列」神秘的Lambda</a><br><br><a href="https://juejin.im/post/5d2ff837f265da1bd424b710" target="_blank" rel="noopener">「Java8系列」神奇的函数式接口</a><br><br>继上两篇之后，本文已经java8系列的第三篇了。本篇文章比较长，但我希望大家都能认真读完。读不完可以先收藏，在找时间读。没看过前两篇的可以点上边的链接看看，前两篇文章算是对是用Stream铺垫的一点基础吧，不过不看也可以学会使用Stream，但看了会有助于更好的理解和使用。在没有深入了解之前，我以为Stream也是数据的载体，但后来发现并不是。那么它到底是什么？听我慢慢道来。</p><h4 id="什么是Stream？"><a href="#什么是Stream？" class="headerlink" title="什么是Stream？"></a>什么是Stream？</h4><p>Stream它并不是一个容器，它只是对容器的功能进行了增强，添加了很多便利的操作,例如查找、过滤、分组、排序等一系列的操作。并且有串行、并行两种执行模式，并行模式充分的利用了多核处理器的优势，使用fork/join框架进行了任务拆分，同时提高了执行速度。简而言之，Stream就是提供了一种高效且易于使用的处理数据的方式。</p><ul><li>特点：</li></ul><ol><li>Stream自己不会存储元素。 </li><li>Stream的操作不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li><li>Stream 操作是延迟执行的。它会等到需要结果的时候才执行。也就是执行终端操作的时候。</li></ol><ul><li>图解：<br><img src="https://user-gold-cdn.xitu.io/2019/7/22/16c198ac61885693?w=1090&h=436&f=png&s=38873" alt="在这里插入图片描述"><br>一个Stream的操作就如上图，在一个管道内，分为三个步骤，第一步是创建Stream，从集合、数组中获取一个流，第二步是中间操作链，对数据进行处理。第三步是终端操作，用来执行中间操作链，返回结果。<h4 id="怎么创建Stream"><a href="#怎么创建Stream" class="headerlink" title="怎么创建Stream?"></a>怎么创建Stream?</h4></li><li>由集合创建：<br>Java8 中的 Collection 接口被扩展，提供了两个获取流的方法,这两个方法是default方法，也就是说所有实现Collection接口的接口都不需要实现就可以直接使用：</li></ul><ol><li>default Stream<e> stream() : 返回一个顺序流。</e></li><li>default Stream<e> parallelStream() : 返回一个并行流。<br><pre><code> 例如：     List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;();     integerList.add(1);     integerList.add(2);     Stream&lt;Integer&gt; stream = integerList.stream();     Stream&lt;Integer&gt; stream1 = integerList.parallelStream();</code></pre></e></li></ol><ul><li>由数组创建：<br>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流:</li></ul><ol><li>static <t> Stream<t> stream(T[] array): 返回一个流</t></t></li><li>重载形式，能够处理对应基本类型的数组:<br><br>public static IntStream stream(int[] array)<br><br>public static LongStream stream(long[] array)<br><br>public static DoubleStream stream(double[] array)<br><pre><code> 例如：     int[] intArray = {1,2,3};     IntStream stream = Arrays.stream(intArray);</code></pre></li></ol><ul><li>由值创建:<br>可以使用静态方法 Stream.of(), 通过显示值 创建一个流。它可以接收任意数量的参数。</li></ul><ol><li>public static<t> Stream<t> of(T… values) : 返回一个流。<br><pre><code> 例如： Stream&lt;Integer&gt; integerStream = Stream.of(1, 2, 3, 4, 5, 6, 7, 8);</code></pre></t></t></li></ol><ul><li>由函数创建：创建无限流<br>可以使用静态方法 Stream.iterate() 和 Stream.generate()创建无限流。</li></ul><ol><li>迭代<br>public static<t> Stream<t> iterate(final T seed, final UnaryOperator<t> f)</t></t></t></li><li>生成<br>public static<t> Stream<t> generate(Supplier<t> s) <pre><code> 例如： Stream.generate(Math::random).limit(5).forEach(System.out::print);  List&lt;Integer&gt; collect = Stream.iterate(0,i -&gt; i + 1).limit(5).collect(Collectors.toList());</code></pre><code>注意：使用无限流一定要配合limit截断，不然会无限制创建下去。</code><h4 id="Stream的中间操作"><a href="#Stream的中间操作" class="headerlink" title="Stream的中间操作"></a>Stream的中间操作</h4>如果Stream只有中间操作是不会执行的，当执行终端操作的时候才会执行中间操作，这种方式称为延迟加载或惰性求值。多个中间操作组成一个中间操作链，只有当执行终端操作的时候才会执行一遍中间操作链，具体是因为什么我们在后面再说明。下面看下Stream有哪些中间操作。</t></t></t></li></ol><ul><li>Stream<code>&lt;T&gt;</code> distinct()：<br>去重，通过流所生成元素的 hashCode() 和 equals() 去除重复元素。<br><img src="https://user-gold-cdn.xitu.io/2019/7/22/16c1a26c389e630e?w=403&h=205&f=jpeg&s=30693" alt><br><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1ce3dc266d996?w=1464&h=1346&f=png&s=269768" alt></li><li>Stream<code>&lt;T&gt;</code> filter(Predicate&lt;? super T&gt; predicate):<br>Predicate函数在上一篇当中我们已经讲过，它是断言型接口，所以filter方法中是接收一个和Predicate函数对应Lambda表达式，返回一个布尔值，从流中过滤某些元素。<br><img src="https://user-gold-cdn.xitu.io/2019/7/22/16c1a2418a587f98?w=403&h=206&f=jpeg&s=26361" alt><br><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1ce5ccf0970d0?w=1464&h=1310&f=png&s=263394" alt></li><li>Stream<code>&lt;T&gt;</code> sorted(Comparator&lt;? super T&gt; comparator):<br>指定比较规则进行排序。<br><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1ce00179fc96a?w=1464&h=1310&f=png&s=264409" alt></li><li>Stream<code>&lt;T&gt;</code> limit(long maxSize):<br>截断流，使其元素不超过给定数量。如果元素的个数小于maxSize，那就获取所有元素。<br><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1ccc8ee241e40?w=403&h=205&f=jpeg&s=30573" alt><br><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1cf0a4636351b?w=1572&h=1346&f=png&s=290113" alt></li><li>Stream<code>&lt;T&gt;</code> skip(long n):<br>跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补。<br><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1ccc8eff0c379?w=403&h=205&f=jpeg&s=26993" alt><br><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1cf3c9ddadd22?w=1724&h=1346&f=png&s=299965" alt></li><li>Stream<code>&lt;R&gt;</code> map(Function&lt;? super T, ? extends R&gt; mapper)：<br>接收一个Function函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。也就是转换操作，map还有三个应用于具体类型方法，分别是：mapToInt，mapToLong和mapToDouble。这三个方法也比较好理解，比如mapToInt就是把原始Stream转换成一个新的Stream，这个新生成的Stream中的元素都是int类型。这三个方法可以免除自动装箱/拆箱的额外消耗。<br><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1ccc8f03ae276?w=403&h=202&f=bmp&s=325678" alt><br><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1cfdc901cae3f?w=1220&h=1454&f=png&s=269788" alt></li><li>Stream<code>&lt;R&gt;</code> flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper)：<br>接收一个Function函数作为参数，将流中的每个值都转换成另一个流，然后把所有流连接成一个流。flatMap也有三个应用于具体类型的方法，分别是：flatMapToInt、flatMapToLong、flatMapToDouble，其作用于map的三个衍生方法相同。<br><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1ccc8f01d9be4?w=403&h=205&f=jpeg&s=30536" alt><br><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1d233eb214db4?w=1870&h=2066&f=png&s=451994" alt></li></ul><h4 id="Stream的终端操作"><a href="#Stream的终端操作" class="headerlink" title="Stream的终端操作"></a>Stream的终端操作</h4><p>终端操作执行中间操作链，并返回结果。终端操作我们就不一一介绍了，只介绍一下常用的操作。详细可看java.util.stream.Stream接口中的方法。</p><ul><li>void forEach(Consumer&lt;? super T&gt; action):<br>内部迭代(需要用户去做迭代，称为外部迭代。相反，Stream API使用内部迭代帮你把迭代做了)<pre><code>users.stream().forEach(user -&gt; System.out.println(user.getName()));</code></pre></li><li>&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector):<br>收集、将流转换为其他形式，比如转换成List、Set、Map。collect方法是用Collector作为参数，Collector接口中方法的实现决定了如何对流执行收集操作(如收集到 List、Set、Map)。但是 Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例。例举一些常用的：<pre><code>List&lt;User&gt; users = Lists.newArrayList();users.add(new User(15, &quot;A&quot;, ImmutableList.of(&quot;1元&quot;, &quot;5元&quot;)));users.add(new User(25, &quot;B&quot;, ImmutableList.of(&quot;10元&quot;, &quot;50元&quot;)));users.add(new User(21, &quot;C&quot;, ImmutableList.of(&quot;100元&quot;)));//收集名称到ListList&lt;String&gt; nameList = users.stream().map(User::getName).collect(Collectors.toList());//收集名称到ListSet&lt;String&gt; nameSet = users.stream().map(User::getName).collect(Collectors.toSet());//收集到map,名字作为key,user对象作为valueMap&lt;String, User&gt; userMap = users.stream()              .collect(Collectors.toMap(User::getName, Function.identity(), (k1, k2) -&gt; k2));</code></pre></li><li>其他终端操作：<ol><li>boolean allMatch(Predicate&lt;? super T&gt; predicate); 检查是否匹配所有元素。</li><li>boolean anyMatch(Predicate&lt;? super T&gt; predicate); 检查是否至少匹配一个元素。</li><li>boolean noneMatch(Predicate&lt;? super T&gt; predicate); 检查是否没有匹配所有元素。</li><li>Optional<code>&lt;T&gt;</code> findFirst(); 返回当前流中的第一个元素。</li><li>Optional<code>&lt;T&gt;</code> findAny(); 返回当前流中的任意元素。</li><li>long count(); 返回流中元素总数。</li><li>Optional<code>&lt;T&gt;</code> max(Comparator&lt;? super T&gt; comparator); 返回流中最大值。</li><li>Optional<code>&lt;T&gt;</code> min(Comparator&lt;? super T&gt; comparator); 返回流中最小值。</li><li>T reduce(T identity, BinaryOperator<code>&lt;T&gt;</code> accumulator); 可以将流中元素反复结合起来，得到一个值。 返回 T。这是一个归约操作。</li></ol></li></ul><h4 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h4><p>上面我们提到过，说Stream的并行模式使用了Fork/Join框架，这里简单说下Fork/Join框架是什么？Fork/Join框架是java7中加入的一个并行任务框架，可以将任务拆分为多个小任务，每个小任务执行完的结果在合并成为一个结果。在任务的执行过程中使用工作窃取（work-stealing）算法，减少线程之间的竞争。</p><ul><li>Fork/Join图解<br><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e40b7eac4b89?w=800&h=426&f=png&s=85559" alt></li><li>工作窃取图解<br><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e414bbc9585b?w=844&h=294&f=png&s=82893" alt><h4 id="Stream是怎么实现的"><a href="#Stream是怎么实现的" class="headerlink" title="Stream是怎么实现的"></a>Stream是怎么实现的</h4>先看下整体类图:蓝色箭头代表继承，绿色箭头代表实现，红色箭头代表内部类。<br><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1ef0992b6e39c?w=982&h=854&f=png&s=760332" alt><br>实际上Stream只有两种操作，中间操作、终端操作，中间操作只是一种标记，只有终端操作才会实际触发执行。所以Stream流水线式的操作大致应该是用某种方式记录中间操作，只有调用终端操作才会将所有的中间操作叠加在一起在一次迭代中全部执行。这里只做简单的介绍，想详细了解的可以参考下面的参考资料中的链接。</li><li>操作怎么记录？<br><br>Stream的操作记录是通过ReferencePipeline记录的，ReferencePipeline有三个内部类Head、StatelessOp、StatefulOp，Stream中使用Stage的概念来描述一个完整的操作，并用某种实例化后的ReferencePipeline来代表Stage，Head用于表示第一个Stage，即调用诸如Collection.stream()方法产生的Stage，很显然这个Stage里不包含任何操作，StatelessOp和StatefulOp分别表示无状态和有状态的Stage，对应于无状态和有状态的中间操作。<br><img src="https://user-gold-cdn.xitu.io/2019/7/24/16c1f94ee4740035?w=1000&h=265&f=png&s=37101" alt></li><li>操作怎么叠加？<br><br>操作是记录完了，但是前面的Stage并不知道后面Stage到底执行了哪种操作，以及回调函数是哪种形式。这就需要有某种协议来协调相邻Stage之间的调用关系。<br>这种协议由Sink接口完成，Sink接口包含的方法如下表所示:</li></ul><ol><li>void begin(long size)，开始遍历元素之前调用该方法，通知Sink做好准备。</li><li>void end()，所有元素遍历完成之后调用，通知Sink没有更多的元素了。</li><li>boolean cancellationRequested()，是否可以结束操作，可以让短路操作尽早结束。</li><li>void accept(T t)，遍历元素时调用，接受一个待处理元素，并对元素进行处理。Stage把自己包含的操作和回调方法封装到该方法里，前一个Stage只需要调用当前Stage.accept(T t)方法就行了。<br></li></ol><p>每个Stage都会将自己的操作封装到一个Sink里，前一个Stage只需调用后一个Stage的accept()方法即可，并不需要知道其内部是如何处理的。有了Sink对操作的包装，Stage之间的调用问题就解决了，执行时只需要从流水线的head开始对数据源依次调用每个Stage对应的Sink.{begin(), accept(), cancellationRequested(), end()}方法就可以了。</p><ul><li>操作怎么执行？<br><img src="https://user-gold-cdn.xitu.io/2019/7/24/16c1fac591c62598?w=600&h=701&f=png&s=60869" alt><br>Sink完美封装了Stream每一步操作，并给出了[处理-&gt;转发]的模式来叠加操作。这一连串的齿轮已经咬合，就差最后一步拨动齿轮启动执行。是什么启动这一连串的操作呢？也许你已经想到了启动的原始动力就是结束操作(Terminal Operation)，一旦调用某个结束操作，就会触发整个流水线的执行。<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><a href="https://ifeve.com/stream" target="_blank" rel="noopener">https://ifeve.com/stream</a><br><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/</a><br><br><a href="https://segmentfault.com/a/1190000016781127" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016781127</a><br><br><a href="https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/6-Stream%20Pipelines.md" target="_blank" rel="noopener">https://github.com/CarpenterLee/JavaLambdaInternals/blob/master/6-Stream%20Pipelines.md</a><br></li></ul><blockquote><p>感谢大家的观看，希望多多关注哦。 如有错误，烦请指正。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Java8系列」神奇的函数式接口</title>
      <link href="/2019/11/03/java8-xi-lie-shen-qi-de-han-shu-shi-jie-kou/"/>
      <url>/2019/11/03/java8-xi-lie-shen-qi-de-han-shu-shi-jie-kou/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在上一篇Lambda的讲解中我们就提到过函数式接口，比如：Consumer<code>&lt;String&gt;</code> consumer = (s) -&gt; System.out.println(s);其中Consumer就是一个函数式接口。这里是通过Lambda表达式创建了一个函数式接口的对象。如果不知道什么是Lambda，请看《<a href="https://juejin.im/post/5d2d15825188253d7201d297" target="_blank" rel="noopener">神秘的Lambda</a>》。</p><h4 id="函数式接口是什么？"><a href="#函数式接口是什么？" class="headerlink" title="函数式接口是什么？"></a>函数式接口是什么？</h4><p>有且只有一个抽象方法的接口被称为函数式接口，函数式接口适用于函数式编程的场景，Lambda就是Java中函数式编程的体现，可以使用Lambda表达式创建一个函数式接口的对象，一定要确保接口中有且只有一个抽象方法，这样Lambda才能顺利的进行推导。</p><h4 id="FunctionalInterface注解"><a href="#FunctionalInterface注解" class="headerlink" title="@FunctionalInterface注解"></a>@FunctionalInterface注解</h4><p>与@Override 注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解：@FunctionalInterface 。该注解可用于一个接口的定义上,一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。但是这个注解不是必须的，只要符合函数式接口的定义，那么这个接口就是函数式接口。</p><h4 id="static方法和default方法"><a href="#static方法和default方法" class="headerlink" title="static方法和default方法"></a>static方法和default方法</h4><p>实在不知道该在哪介绍这两个方法了，所以就穿插在这里了。</p><h5 id="static方法："><a href="#static方法：" class="headerlink" title="static方法："></a>static方法：</h5><p>java8中为接口新增了一项功能，定义一个或者多个静态方法。用法和普通的static方法一样,例如：</p><pre><code>public interface Interface {    /**     * 静态方法     */    static void staticMethod() {        System.out.println(&quot;static method&quot;);    }}</code></pre><p><code>注意:实现接口的类或者子接口不会继承接口中的静态方法。</code></p><h5 id="default方法："><a href="#default方法：" class="headerlink" title="default方法："></a>default方法：</h5><p>java8在接口中新增default方法，是为了在现有的类库中中新增功能而不影响他们的实现类，试想一下，如果不增加默认实现的话，接口的所有实现类都要实现一遍这个方法，这会出现兼容性问题，如果定义了默认实现的话，那么实现类直接调用就可以了，并不需要实现这个方法。default方法怎么定义？</p><pre><code>public interface Interface {    /**     * default方法     */    default void print() {        System.out.println(&quot;hello default&quot;);    }}</code></pre><p><code>注意：如果接口中的默认方法不能满足某个实现类需要，那么实现类可以覆盖默认方法。不用加default关键字，</code>例如：</p><pre><code>public class InterfaceImpl implements Interface {    @Override    public  void print() {        System.out.println(&quot;hello default 2&quot;);    }}</code></pre><p>在函数式接口的定义中是只允许有一个抽象方法，但是可以有多个static方法和default方法。</p><h4 id="自定义函数式接口"><a href="#自定义函数式接口" class="headerlink" title="自定义函数式接口"></a>自定义函数式接口</h4><p>按照下面的格式定义，你也能写出函数式接口：</p><pre><code> @FunctionalInterface 修饰符 interface 接口名称 {    返回值类型 方法名称(可选参数信息);    // 其他非抽象方法内容 }</code></pre><p>虽然@FunctionalInterface注解不是必须的，但是自定义函数式接口最好还是都加上，一是养成良好的编程习惯，二是防止他人修改，一看到这个注解就知道是函数式接口，避免他人往接口内添加抽象方法造成不必要的麻烦。</p><pre><code>@FunctionalInterfacepublic interface MyFunction {    void print(String s);}</code></pre><p>看上图是我自定义的一个函数式接口，那么这个接口的作用是什么呢？就是输出一串字符串，属于消费型接口，是模仿Consumer接口写的，只不过这个没有使用泛型，而是将参数具体类型化了，不知道Consumer没关系，下面会介绍到，其实java8中提供了很多常用的函数式接口，Consumer就是其中之一，一般情况下都不需要自己定义，直接使用就好了。那么怎么使用这个自定义的函数式接口呢？我们可以用函数式接口作为参数，调用时传递Lambda表达式。如果一个方法的参数是Lambda，那么这个参数的类型一定是函数式接口。例如：</p><pre><code>public class MyFunctionTest {    public static void main(String[] args) {        String text = &quot;试试自定义函数好使不&quot;;        printString(text, System.out::print);    }    private static void printString(String text, MyFunction myFunction) {        myFunction.print(text);    }}</code></pre><p>执行以后就会输出“试试自定义函数好使不”这句话，如果某天需求变了，我不想输出这句话了，想输出别的，那么直接替换text就好了。函数式编程是没有副作用的，最大的好处就是函数的内部是无状态的，既输入确定输出就确定。函数式编程还有更多好玩的套路，这就需要靠大家自己探索了。😝</p><h4 id="常用函数式接口"><a href="#常用函数式接口" class="headerlink" title="常用函数式接口"></a>常用函数式接口</h4><h5 id="Consumer-lt-T-gt-：消费型接口"><a href="#Consumer-lt-T-gt-：消费型接口" class="headerlink" title="Consumer&lt;T&gt;：消费型接口"></a>Consumer<code>&lt;T&gt;</code>：消费型接口</h5><p><strong>抽象方法：</strong>  void accept(T t)，接收一个参数进行消费，但无需返回结果。</p><p><strong>使用方式：</strong></p><pre><code>  Consumer consumer = System.out::println;  consumer.accept(&quot;hello function&quot;);</code></pre><p><strong>默认方法：</strong> andThen(Consumer&lt;? super T&gt; after)，先消费然后在消费，先执行调用andThen接口的accept方法，然后在执行andThen方法参数after中的accept方法。</p><p><strong>使用方式：</strong>        </p><pre><code>  Consumer&lt;String&gt; consumer1 = s -&gt; System.out.print(&quot;车名：&quot;+s.split(&quot;,&quot;)[0]);  Consumer&lt;String&gt; consumer2 = s -&gt; System.out.println(&quot;--&gt;颜色：&quot;+s.split(&quot;,&quot;)[1]);  String[] strings = {&quot;保时捷,白色&quot;, &quot;法拉利,红色&quot;};  for (String string : strings) {     consumer1.andThen(consumer2).accept(string);  }</code></pre><p><strong>输出：</strong><br>车名：保时捷–&gt;颜色：白色<br>车名：法拉利–&gt;颜色：红色</p><h5 id="Supplier-lt-T-gt-供给型接口"><a href="#Supplier-lt-T-gt-供给型接口" class="headerlink" title="Supplier&lt;T&gt;: 供给型接口"></a>Supplier<code>&lt;T&gt;</code>: 供给型接口</h5><p><strong>抽象方法</strong>：T get()，无参数，有返回值。</p><p><strong>使用方式：</strong></p><pre><code> Supplier&lt;String&gt; supplier = () -&gt; &quot;我要变的很有钱&quot;; System.out.println(supplier.get());</code></pre><p>最后输出就是“我要变得很有钱”，这类接口适合提供数据的场景。</p><h5 id="Function-lt-T-R-gt-函数型接口"><a href="#Function-lt-T-R-gt-函数型接口" class="headerlink" title="Function&lt;T,R&gt;: 函数型接口"></a>Function<code>&lt;T,R&gt;</code>: 函数型接口</h5><p><strong>抽象方法：</strong> R apply(T t)，传入一个参数，返回想要的结果。</p><p><strong>使用方式：</strong></p><pre><code> Function&lt;Integer, Integer&gt; function1 = e -&gt; e * 6; System.out.println(function1.apply(2));</code></pre><p>很简单的一个乘法例子，显然最后输出是12。</p><p><strong>默认方法：</strong></p><ul><li>compose(Function&lt;? super V, ? extends T&gt; before)，先执行compose方法参数before中的apply方法，然后将执行结果传递给调用compose函数中的apply方法在执行。</li></ul><p><strong>使用方式：</strong></p><pre><code> Function&lt;Integer, Integer&gt; function1 = e -&gt; e * 2; Function&lt;Integer, Integer&gt; function2 = e -&gt; e * e; Integer apply2 = function1.compose(function2).apply(3); System.out.println(apply2);</code></pre><p>还是举一个乘法的例子，compose方法执行流程是先执行function2的表达式也就是3<em>3=9，然后在将执行结果传给function1的表达式也就是9</em>2=18，所以最终的结果是18。</p><ul><li>andThen(Function&lt;? super R, ? extends V&gt; after)，先执行调用andThen函数的apply方法，然后在将执行结果传递给andThen方法after参数中的apply方法在执行。它和compose方法整好是相反的执行顺序。</li></ul><p><strong>使用方式：</strong></p><pre><code> Function&lt;Integer, Integer&gt; function1 = e -&gt; e * 2; Function&lt;Integer, Integer&gt; function2 = e -&gt; e * e; Integer apply3 = function1.andThen(function2).apply(3); System.out.println(apply3);</code></pre><p>这里我们和compose方法使用一个例子，所以是一模一样的例子，由于方法的不同，执行顺序也就不相同，那么结果是大大不同的。andThen方法是先执行function1表达式，也就是3<em>2=6，然后在执行function2表达式也就是6</em>6=36。结果就是36。<br><strong>静态方法：</strong>identity()，获取一个输入参数和返回结果相同的Function实例。</p><p><strong>使用方式：</strong> </p><pre><code> Function&lt;Integer, Integer&gt; identity = Function.identity(); Integer apply = identity.apply(3); System.out.println(apply);</code></pre><p>平常没有遇到过使用这个方法的场景，总之这个方法的作用就是输入什么返回结果就是什么。</p><h5 id="Predicate-lt-T-gt-：-断言型接口"><a href="#Predicate-lt-T-gt-：-断言型接口" class="headerlink" title="Predicate&lt;T&gt; ： 断言型接口"></a>Predicate<code>&lt;T&gt;</code> ： 断言型接口</h5><p><strong>抽象方法：</strong> boolean test(T t),传入一个参数，返回一个布尔值。</p><p><strong>使用方式：</strong></p><pre><code> Predicate&lt;Integer&gt; predicate = t -&gt; t &gt; 0; boolean test = predicate.test(1); System.out.println(test);</code></pre><p>当predicate函数调用test方法的时候，就会执行拿test方法的参数进行t -&gt; t &gt; 0的条件判断，1肯定是大于0的，最终结果为true。</p><p><strong>默认方法：</strong></p><ul><li>and(Predicate&lt;? super T&gt; other)，相当于逻辑运算符中的&amp;&amp;，当两个Predicate函数的返回结果都为true时才返回true。</li></ul><p><strong>使用方式：</strong></p><pre><code> Predicate&lt;String&gt; predicate1 = s -&gt; s.length() &gt; 0; Predicate&lt;String&gt; predicate2 = Objects::nonNull; boolean test = predicate1.and(predicate2).test(&quot;&amp;&amp;测试&quot;); System.out.println(test);</code></pre><ul><li>or(Predicate&lt;? super T&gt; other) ,相当于逻辑运算符中的||，当两个Predicate函数的返回结果有一个为true则返回true，否则返回false。</li></ul><p><strong>使用方式：</strong></p><pre><code> Predicate&lt;String&gt; predicate1 = s -&gt; false; Predicate&lt;String&gt; predicate2 = Objects::nonNull; boolean test = predicate1.and(predicate2).test(&quot;||测试&quot;); System.out.println(test);</code></pre><ul><li>negate()，这个方法的意思就是取反。</li></ul><p><strong>使用方式：</strong></p><pre><code> Predicate&lt;String&gt; predicate = s -&gt; s.length() &gt; 0; boolean result = predicate.negate().test(&quot;取反&quot;); System.out.println(result);</code></pre><p>很明显正常执行test方法的话应该为true，但是调用negate方法后就返回为false了。<br><strong>静态方法：</strong>isEqual(Object targetRef)，对当前操作进行”=”操作,即取等操作,可以理解为 A == B。</p><p><strong>使用方式:</strong></p><pre><code> boolean test1 = Predicate.isEqual(&quot;test&quot;).test(&quot;test&quot;); boolean test2 = Predicate.isEqual(&quot;test&quot;).test(&quot;equal&quot;); System.out.println(test1);   //true System.out.println(test2);   //false</code></pre><h4 id="其他函数式接口"><a href="#其他函数式接口" class="headerlink" title="其他函数式接口"></a>其他函数式接口</h4><h5 id="Bi类型接口"><a href="#Bi类型接口" class="headerlink" title="Bi类型接口"></a>Bi类型接口</h5><p>BiConsumer、BiFunction、BiPrediate 是 Consumer、Function、Predicate 的扩展，可以传入多个参数，没有 BiSupplier 是因为 Supplier 没有入参。</p><h5 id="操作基本数据类型的接口"><a href="#操作基本数据类型的接口" class="headerlink" title="操作基本数据类型的接口"></a>操作基本数据类型的接口</h5><p>IntConsumer、IntFunction、IntPredicate、IntSupplier、LongConsumer、LongFunction、LongPredicate、LongSupplier、DoubleConsumer、DoubleFunction、DoublePredicate、DoubleSupplier。<br>其实常用的函数式接口就那四大接口Consumer、Function、Prediate、Supplier，其他的函数式接口就不一一列举了，有兴趣的可以去java.util.function这个包下详细的看。</p><blockquote><p>感谢大家的观看，希望多多关注哦。 如有错误，烦请指正。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Go学习笔记」2.Go语言由什么组成？</title>
      <link href="/2019/11/02/go-xue-xi-bi-ji-2-go-yu-yan-you-shi-me-zu-cheng/"/>
      <url>/2019/11/02/go-xue-xi-bi-ji-2-go-yu-yan-you-shi-me-zu-cheng/</url>
      
        <content type="html"><![CDATA[<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>Go语言标识符是用于标识变量、函数或任何用户自定义项目的名称（程序实体），这个标识符就类似java中的数据类型（基本数据类型、引用数据类型）。标识符有两种类别，一种是用户自定义的标识符，它作为程序的实体存在。另一种标识符成为预定义标识符，是Go语言源代码中声明的。例如：</p><ol><li><p>数据类型</p><p>bool（true和false）、byte、uint、uint8、uint16、uint32、uint64、int、int8、int16、int32、int64、float32、float64、string、uintptr。</p></li><li><p>内建函数名</p><p>append、cap、close、complex、copy、delete、imag、len、make、new、panic、print、println、real、recover。</p></li><li><p>其他标识符</p><p>iota、nil、_ 。</p><p>最后一个_叫做空标识符，一般用在变量声明与包的导入中，类似Java中的null。</p></li></ol><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>Go语言作为一门静态编译型语言，它的关键字一共有25个，相比他语言显得非常少，java关键字就有50个，不过感觉Go语言的关键字少的原因也是因为它把数据类型和关键字分开了，数据类型叫做标识符了，下面是Go语言的25个关键字</p><ol><li><p>包导入与声明</p><p>import、package。</p></li><li><p>程序实体声明与定义</p><p>var、type、func、interface、map、struct、chan、const。</p></li><li><p>流程控制</p><p>if、continue、for、return、go、case、goto、switch、select、clse、break、default、defer、fallthrough、range。</p></li></ol><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>字面量就是表示值得一种标记法，在Go语言中，字面量的含义要更广一些，首先，它用于表示基础数据类型的各种字面量，其次用于标识用户构造的自定义复合数据类型的字面量，最后它还用于标识复合数据类型的值的复合字面量，简单来说它会被用来构造Struct（结构体）、Array（数组）、Slice（切片）和Map（字典）的值。</p><p>例如：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">const</span> b <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">10</span> <span class="token comment" spellcheck="true">//b为常量，10为字面量</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h3><p>分隔符用来分隔Go语言中的元素，例如：</p><pre class="line-numbers language-go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello ，World"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>分隔符包括括号、中括号、大括号、小数点、逗号、分号、冒号、省略号。Go语言不需要像java那样每行代码都要以分号（;）结尾。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>运算符是用来执行运算或逻辑操作的符号，Go语言中的运算符如下图所示</p><ol><li>运算符<br><img src="https://user-gold-cdn.xitu.io/2019/10/19/16de344d04dffd76?w=1460&h=1002&f=png&s=1362101" alt><br><img src="https://user-gold-cdn.xitu.io/2019/10/19/16de344fb5ae925c?w=1460&h=268&f=png&s=245596" alt></li><li>运算符优先级：<br><img src="https://user-gold-cdn.xitu.io/2019/10/19/16de34450aea1678?w=998&h=381&f=png&s=23293" alt><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3>Go语言中的注释有多种写法和Java差不多。<pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 单行注释</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">/*这是一条Go注释*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">/*这是一段Go注释*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>感谢大家的观看，希望多多关注哦。 如有错误，烦请指正。</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> GO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUnit4教程+实践</title>
      <link href="/2019/11/01/junit4-jiao-cheng-shi-jian/"/>
      <url>/2019/11/01/junit4-jiao-cheng-shi-jian/</url>
      
        <content type="html"><![CDATA[<p><img src="junit.jpg" alt></p><h4 id="一、什么是JUnit？"><a href="#一、什么是JUnit？" class="headerlink" title="一、什么是JUnit？"></a>一、什么是JUnit？</h4><p>JUnit是Java编程语言的单元测试框架，用于编写和可重复运行的自动化测试。</p><h4 id="二、JUnit特点："><a href="#二、JUnit特点：" class="headerlink" title="二、JUnit特点："></a>二、JUnit特点：</h4><ul><li>JUnit 是一个开放的资源框架，用于编写和运行测试。 </li><li>提供注解来识别测试方法。</li><li>提供断言来测试预期结果。 </li><li>JUnit 测试允许你编写代码更快，并能提高质量。</li><li>JUnit 优雅简洁。没那么复杂，花费时间较少。 </li><li>JUnit测试可以自动运行并且检查自身结果并提供即时反馈。所以也没有必要人工梳理测试结果的报告。 </li><li>JUnit测试可以被组织为测试套件，包含测试用例，甚至其他的测试套件。 </li><li>JUnit在一个条中显示进度。如果运行良好则是绿色；如果运行失败，则变成红色。</li></ul><h4 id="三、JUnit注解"><a href="#三、JUnit注解" class="headerlink" title="三、JUnit注解"></a>三、JUnit注解</h4><table><thead><tr><th>注解</th><th>描述</th></tr></thead><tbody><tr><td>@Test</td><td>测试注解，标记一个方法可以作为一个测试用例 。</td></tr><tr><td>@Before</td><td>Before注解表示，该方法必须在类中的每个测试之前执行,以便执行某些必要的先决条件。</td></tr><tr><td>@BeforeClass</td><td>BeforeClass注解指出这是附着在静态方法必须执行一次并在类的所有测试之前，这种情况一般用于测试计算、共享配制方法(如数据库连接)。</td></tr><tr><td>@After</td><td>After注释表示，该方法在每项测试后执行（如执行每一个测试后重置某些变量，删除临时变量等）。</td></tr><tr><td>@AfterClass</td><td>当需要执行所有测试在JUnit测试用例类后执行，AlterClass注解可以使用以清理一些资源（如数据库连接），注意：方法必须为静态方法。</td></tr><tr><td>@Ignore</td><td>当想暂时禁用特定的测试执行可以使用这个注解，每个被注解为@Ignore的方法将不再执行</td></tr><tr><td>@Runwith</td><td>@Runwith就是放在测试类名之前，用来确定这个类怎么运行的。也可以不标注，会使用默认运行器。</td></tr><tr><td>@Parameters</td><td>用于使用参数化功能。</td></tr><tr><td>@SuiteClasses</td><td>用于套件测试</td></tr></tbody></table><h4 id="四、JUnit断言"><a href="#四、JUnit断言" class="headerlink" title="四、JUnit断言"></a>四、JUnit断言</h4><table><thead><tr><th>断言</th><th>描述</th></tr></thead><tbody><tr><td>void assertEquals([String message],expected value,actual value)</td><td>断言两个值相等。值类型可能是int，short，long，byte，char，Object，第一个参数是一个可选字符串消息</td></tr><tr><td>void assertTrue([String message],boolean condition)</td><td>断言一个条件为真</td></tr><tr><td>void assertFalse([String message],boolean condition)</td><td>断言一个条件为假</td></tr><tr><td>void assertNotNull([String message],java.lang.Object object)</td><td>断言一个对象不为空（null）</td></tr><tr><td>void assertNull([String message],java.lang.Object object)</td><td>断言一个对象为空（null）</td></tr><tr><td>void assertSame([String message],java.lang.Object expected,java.lang.Object actual)</td><td>断言两个对象引用相同的对象</td></tr><tr><td>void assertNotSame([String message],java.lang.Object unexpected,java.lang.Object actual)</td><td>断言两个对象不是引用同一个对象</td></tr><tr><td>void assertArrayEquals([String message],expectedArray,resultArray)</td><td>断言预期数组和结果数组相等，数组类型可能是int，short，long，byte，char，Object</td></tr></tbody></table><p>让我们看下使用断言的例子。<br>AssertionTest.java</p><pre><code>public class AssertionTest {    @Test    public void test() {        String obj1 = &quot;junit&quot;;        String obj2 = &quot;junit&quot;;        String obj3 = &quot;test&quot;;        String obj4 = &quot;test&quot;;        String obj5 = null;        int var1 = 1;        int var2 = 2;        int[] array1 = {1, 2, 3};        int[] array2 = {1, 2, 3};        Assert.assertEquals(obj1, obj2);        Assert.assertSame(obj3, obj4);        Assert.assertNotSame(obj2, obj4);        Assert.assertNotNull(obj1);        Assert.assertNull(obj5);        Assert.assertTrue(var1 &lt; var2);        Assert.assertFalse(var1 &gt; var2);        Assert.assertArrayEquals(array1, array2);    }}</code></pre><p>在以上类中我们可以看到，这些断言方法是可以工作的。  </p><ul><li>assertEquals() 如果比较的两个对象是相等的，此方法将正常返回；否则失败显示在JUnit的窗口测试将中止。  </li><li>assertSame() 和 assertNotSame() 方法测试两个对象引用指向完全相同的对象。  </li><li>assertNull() 和 assertNotNull() 方法测试一个变量是否为空或不为空(null)。  </li><li>assertTrue() 和 assertFalse() 方法测试if条件或变量是true还是false。  </li><li>assertArrayEquals() 将比较两个数组，如果它们相等，则该方法将继续进行不会发出错误。否则失败将显示在JUnit窗口和中止测试。</li></ul><h4 id="五、JUnit执行过程"><a href="#五、JUnit执行过程" class="headerlink" title="五、JUnit执行过程"></a>五、JUnit执行过程</h4><p>JuntiTest.java</p><pre><code>public class JunitTest {    @BeforeClass    public static void beforeClass() {        System.out.println(&quot;in before class&quot;);    }    @AfterClass    public static void afterClass() {        System.out.println(&quot;in after class&quot;);    }    @Before    public void before() {        System.out.println(&quot;in before&quot;);    }    @After    public void after() {        System.out.println(&quot;in after&quot;);    }    @Test    public void testCase1() {        System.out.println(&quot;in test case 1&quot;);    }    @Test    public void testCase2() {        System.out.println(&quot;in test case 2&quot;);    }}</code></pre><p>通过idea执行整个测试类后，执行结果：</p><pre><code>in before classin beforein test case 1in afterin beforein test case 2in afterin after class</code></pre><h4 id="六、忽略测试"><a href="#六、忽略测试" class="headerlink" title="六、忽略测试"></a>六、忽略测试</h4><ul><li>一个带有@Ignore注解的测试方法不会被执行</li><li>如果一个测试类带有@Ignore注解，则它的测试方法将不会被执行</li></ul><p>我们把刚才测试类中的testCase2()方法标记为@Ignore,</p><pre><code>    @Ignore    @Test    public void testCase2() {        System.out.println(&quot;in test case 2&quot;);    }</code></pre><p>然后在执行测试类的时候就会忽视这个方法，结果为：</p><pre><code>in before classin beforein test case 1in afterTest ignored.in after class</code></pre><h4 id="七、时间测试"><a href="#七、时间测试" class="headerlink" title="七、时间测试"></a>七、时间测试</h4><p>JUnit提供了一个暂停的方便选项，如果一个测试用例比起指定的毫秒数花费了更多的时间，那么JUnit将自动将它标记为失败，timeout参数和@Test注解一起使用，例如@Test(timeout=1000)。<br>继续使用刚才的例子，现在将testCase1的执行时间延长到5000毫秒，并加上时间参数,设置超时为1000毫秒，然后执行测试类</p><pre><code>    @Test(timeout = 1000)    public void testCase1() throws InterruptedException {        TimeUnit.SECONDS.sleep(5000);        System.out.println(&quot;in test case 1&quot;);    }</code></pre><p>testCase1被标记为失败，并且抛出异常，执行结果：</p><pre><code>in before classin beforein afterorg.junit.runners.model.TestTimedOutException: test timed out after 1000 milliseconds    at java.lang.Thread.sleep(Native Method)    at java.lang.Thread.sleep(Thread.java:340)    at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)    at com.lxs.JUnit.JunitTest.testCase1(JunitTest.java:35)    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)    at java.lang.reflect.Method.invoke(Method.java:498)    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)    at org.junit.internal.runners.statements.FailOnTimeout$CallableStatement.call(FailOnTimeout.java:298)    at org.junit.internal.runners.statements.FailOnTimeout$CallableStatement.call(FailOnTimeout.java:292)    at java.util.concurrent.FutureTask.run(FutureTask.java:266)    at java.lang.Thread.run(Thread.java:748)in beforein test case 2in afterin after class</code></pre><h4 id="八、异常测试"><a href="#八、异常测试" class="headerlink" title="八、异常测试"></a>八、异常测试</h4><p>Junit 用代码处理提供了一个追踪异常的选项。你可以测试代码是否它抛出了想要得到的异常。expected 参数和 @Test 注释一起使用。现在让我们看看 @Test(expected)。新建测试方法testCase3()。</p><pre><code>    @Test(expected = ArithmeticException.class)    public void testCase3() {        System.out.println(&quot;in test case 3&quot;);        int a = 0;        int b = 1 / a;    }</code></pre><p>单独执行testCase3()方法，由于得到了一个预期异常，所以测试通过，结果为</p><pre><code>in before classin beforein test case 3in afterin after class</code></pre><p>如果没有得到预期异常：</p><pre><code>in before classin beforein test case 3in afterjava.lang.AssertionError: Expected exception: java.lang.ArithmeticExceptionin after class</code></pre><h4 id="九、参数化测试"><a href="#九、参数化测试" class="headerlink" title="九、参数化测试"></a>九、参数化测试</h4><p>Junit 4 引入了一个新的功能参数化测试。参数化测试允许开发人员使用不同的值反复运行同     一个测试。你将遵循 5 个步骤来创建参数化测试：</p><p> -为准备使用参数化测试的测试类指定特殊的运行器 org.junit.runners.Parameterized。</p><ul><li>为测试类声明几个变量，分别用于存放期望值和测试所用数据。</li><li>为测试类声明一个带有参数的公共构造函数，并在其中为第二个环节中声明的几个变量赋值。</li><li>为测试类声明一个使用注解 org.junit.runners.Parameterized.Parameters 修饰的，返回值为 java.util.Collection 的公共静态方法，并在此方法中初始化所有需要测试的参数对。</li><li>编写测试方法，使用定义的变量作为参数进行测试。</li></ul><h6 id="什么是-RunWith"><a href="#什么是-RunWith" class="headerlink" title="什么是@RunWith?"></a>什么是@RunWith?</h6><p> 首先要分清几个概念：测试方法、测试类、测试集、测试运行器。</p><ul><li>其中测试方法就是用@Test注解的一些函数。</li><li>测试类是包含一个或多个测试方法的一个**Test.java文件，</li><li>测试集是一个suite，可能包含多个测试类。</li><li>测试运行器则决定了用什么方式偏好去运行这些测试集/类/方法。</li></ul><p>而@Runwith就是放在测试类名之前，用来确定这个类怎么运行的。也可以不标注，会使用默认运行器。常见的运行器有：</p><ul><li>@RunWith(Parameterized.class) 参数化运行器，配合@Parameters使用JUnit的参数化功能</li><li>@RunWith(Suite.class)<br>@SuiteClasses({ATest.class,BTest.class,CTest.class})<br>测试集运行器配合使用测试集功能</li><li>@RunWith(JUnit4.class)，    junit4的默认运行器</li><li>@RunWith(JUnit38ClassRunner.class)，用于兼容junit3.8的运行器</li><li>一些其它运行器具备更多功能。例如@RunWith(SpringJUnit4ClassRunner.class)集成了spring的一些功能</li></ul><p>PrimeNumberCheckerTest.java</p><pre><code>/** * 步骤一: 指定定参数运行器 */@RunWith(Parameterized.class)public class PrimeNumberCheckerTest {    /**     * 步骤二：声明变量     */    private Integer inputNumber;    private Boolean expectedResult;    private PrimeNumberChecker primeNumberChecker;    /**     * 步骤三：为测试类声明一个带有参数的公共构造函数，为变量赋值     */    public PrimeNumberCheckerTest(Integer inputNumber,                                  Boolean expectedResult) {        this.inputNumber = inputNumber;        this.expectedResult = expectedResult;    }    /**     * 步骤四：为测试类声明一个使用注解 org.junit.runners.Parameterized.Parameters 修饰的，返回值为     * java.util.Collection 的公共静态方法，并在此方法中初始化所有需要测试的参数对     *   1）该方法必须由Parameters注解修饰           2）该方法必须为public static的           3）该方法必须返回Collection类型           4）该方法的名字不做要求           5）该方法没有参数      */    @Parameterized.Parameters    public static Collection primeNumbers() {        return Arrays.asList(new Object[][]{                {2, true},                {6, false},                {19, true},                {22, false},                {23, true}        });    }    @Before    public void initialize() {        primeNumberChecker = new PrimeNumberChecker();    }    /**     * 步骤五：编写测试方法，使用自定义变量进行测试     */    @Test    public void testPrimeNumberChecker() {        System.out.println(&quot;Parameterized Number is : &quot; + inputNumber);        Assert.assertEquals(expectedResult,                primeNumberChecker.validate(inputNumber));    }}</code></pre><p>PrimeNumberChecker.java</p><pre><code>public class PrimeNumberChecker {    public Boolean validate(final Integer parimeNumber) {        for (int i = 2; i &lt; (parimeNumber / 2); i++) {            if (parimeNumber % i == 0) {                return false;            }        }        return true;    }}</code></pre><p>JUnit会按照设置的参数多次执行，执行结果：</p><pre><code>Parameterized Number is : 2Parameterized Number is : 6Parameterized Number is : 19Parameterized Number is : 22Parameterized Number is : 23</code></pre><h4 id="十、套件测试"><a href="#十、套件测试" class="headerlink" title="十、套件测试"></a>十、套件测试</h4><p>“套件测试”是指捆绑了几个单元测试用例并运行起来。在JUnit中，@RunWith 和 @Suite 这两个注解是用来运行套件测试。先来创建几个测试类</p><pre><code>public class JunitTest1 {    @Test    public void printMessage(){        System.out.println(&quot;in JunitTest1&quot;);    }}</code></pre><pre><code>public class JunitTest2 {    @Test    public void printMessage(){        System.out.println(&quot;in JunitTest2&quot;);    }}</code></pre><pre><code>@RunWith(Suite.class)@Suite.SuiteClasses({        /**         * 此处类的配置顺序会影响执行顺序         */        JunitTest1.class,        JunitTest2.class})public class JunitSuite {}</code></pre><p>执行JunitSuite测试类，执行结果：</p><pre><code>in JunitTest1in JunitTest2</code></pre><blockquote><p>感谢大家的观看，希望多多关注哦。 如有错误，烦请指正。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUnit4 </tag>
            
            <tag> 单元测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Java8系列」神秘的Lambda</title>
      <link href="/2019/10/31/java8-xi-lie-shen-mi-de-lambda/"/>
      <url>/2019/10/31/java8-xi-lie-shen-mi-de-lambda/</url>
      
        <content type="html"><![CDATA[<h4 id="接触背景"><a href="#接触背景" class="headerlink" title="接触背景"></a>接触背景</h4><p>第一次接触lambda表达式时，感觉这个东西挺神奇的（高逼格），一个（）加-&gt;就能传递一段代码，当时公司项目中接手同事的代码，自己也对java8的特性不了解，看的也是一头雾水，之后就赶快看了下《java8实战》这本书，决定写一个java8特性系列的博客，既加深自己的印象，还能跟大家分享一下，希望大家多多指教😄。</p><h4 id="什么是Lambda？"><a href="#什么是Lambda？" class="headerlink" title="什么是Lambda？"></a>什么是Lambda？</h4><p>Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码(将代码像参数一样进行传递，称为行为参数化)。Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中），要做到这一点就需要了解，什么是函数式接口，这里先不做介绍，等下一篇在讲解。</p><p>首先先看一下lambda长什么样？<br>正常写法：</p><pre><code>new Thread(new Runnable() {    @Override    public void run() {       System.out.println(&quot;hello lambda&quot;);    }}).start();</code></pre><p>lambda写法：</p><pre><code>new Thread(    () -&gt; System.out.println(&quot;hello lambda&quot;)).start();</code></pre><p>怎么样？是不是感觉很简洁，没错，这就是lambda的魅力，他可以让你写出来的代码更简单、更灵活。</p><h4 id="Lambda怎么写？"><a href="#Lambda怎么写？" class="headerlink" title="Lambda怎么写？"></a>Lambda怎么写？</h4><p><img src="https://user-gold-cdn.xitu.io/2019/7/16/16bf81c30ea9b895?w=798&h=434&f=png&s=59257" alt><br>大家看一些上面的这个图，这就是lambda的语法，一个lambda分为三部分：参数列表、操作符、lambda体。以下是lambda表达式的重要特征：</p><ul><li><code>可选类型声明：</code><br>不需要声明参数类型，编译器可以统一识别参数值。也就说(s) -&gt; System.out.println(s)和<br>(String s) -&gt; System.out.println(s)是一样的编译器会进行类型推断所以不需要添加参数类型。</li><li><code>可选的参数圆括号：</code><br>一个参数无需定义圆括号，但多个参数需要定义圆括号。例如：<ol><li>s -&gt; System.out.println(s)  一个参数不需要添加圆括号。</li><li>(x, y) -&gt; Integer.compare(y, x) 两个参数添加了圆括号，否则编译器报错。</li></ol></li><li><code>可选的大括号：</code><br>如果主体包含了一个语句，就不需要使用大括号。<ol><li>s -&gt; System.out.println(s) , 不需要大括号.</li><li>(s) -&gt; {<pre><code>     if (s.equals(&quot;s&quot;)){        System.out.println(s);     }</code></pre>   };    需要大括号</li></ol></li><li><code>可选的返回关键字：</code><br>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li></ul><p>Lambda体不加{ }就不用写return:</p><pre><code> Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(y, x); </code></pre><p>  Lambda体加上{ }就需要添加return:</p><pre><code>  Comparator&lt;Integer&gt; com = (x, y) -&gt; {            int compare = Integer.compare(y, x);            return compare;        }; </code></pre><h4 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h4><p>   上面我们看到了一个lambda表达式应该怎么写，但lambda中有一个重要特征是<code>可选参数类型声明</code>，就是说不用写参数的类型，那么为什么不用写呢？它是怎么知道的参数类型呢？这就涉及到类型推断了。</p><p><strong>java8的泛型类型推断改进：</strong></p><ul><li>支持通过方法上下文推断泛型目标类型</li><li>支持在方法调用链路中，泛型类型推断传递到最后一个方法</li></ul><pre><code>List&lt;Person&gt; ps = ...Stream&lt;String&gt; names = ps.stream().map(p -&gt; p.getName());</code></pre><p>  在上面的代码中，ps的类型是List<code>&lt;Person&gt;</code>，所以ps.stream()的返回类型是Stream<code>&lt;Person&gt;</code>。map()方法接收一个类型为Function&lt;T, R&gt;的函数式接口，这里T的类型即是Stream元素的类型，也就是Person，而R的类型未知。由于在重载解析之后lambda表达式的目标类型仍然未知，我们就需要推导R的类型：通过对lambda表达式lambda进行类型检查，我们发现lambda体返回String，因此R的类型是String，因而map()返回Stream<code>&lt;String&gt;</code>。绝大多数情况下编译器都能解析出正确的类型，但如果碰到无法解析的情况，我们则需要：</p><ul><li>使用显式lambda表达式（为参数p提供显式类型）以提供额外的类型信息</li><li>把lambda表达式转型为Function&lt;Person, String&gt;</li><li>为泛型参数R提供一个实际类型。（ <code>&lt;String&gt;</code>map(p -&gt; p.getName())）</li></ul><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>方法引用是用来直接访问类或者实例已经存在的方法或构造方法，提供了一种引用而不执行方法的方式。是一种更简洁更易懂的Lambda表达式，当Lambda表达式中只是执行一个方法调用时，直接使用方法引用的形式可读性更高一些。<br> 方法引用使用 “ :: ” 操作符来表示，左边是类名或实例名，右边是方法名。<br><code>（注意：方法引用::右边的方法名是不需要加（）的，例：User::getName）</code></p><p><strong>方法引用的几种形式：</strong></p><ul><li>类 :: 静态方法</li><li>类 :: 实例方法</li><li>对象 :: 实例方法</li></ul><pre><code>例如：    Consumer&lt;String&gt; consumer = (s) -&gt; System.out.println(s);等同于：    Consumer&lt;String&gt; consumer = System.out::println;例如：    Function&lt;String, Integer&gt; stringToInteger = (String s) -&gt; Integer.parseInt(s);等同于：    Function&lt;String, Integer&gt; stringToInteger = Integer::parseInt;例如：    BiPredicate&lt;List&lt;String&gt;, String&gt; contains = (list, element) -&gt; list.contains(element);等同于：    BiPredicate&lt;List&lt;String&gt;, String&gt; contains = List::contains;</code></pre><p><strong><code>注意:</code></strong></p><ul><li>Lambda体中调用方法的参数列表与返回值类型，要与函数式接口中抽象方法的函数列表和返回值类型保存一致</li><li>若Lambda参数列表中的第一个参数是实例方法的调用者，而第二个参数是实例方法的参数时，可以使用ClassName::method</li></ul><h4 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h4><p>语法格式：类名::new</p><pre><code>例如：    Supplier&lt;User&gt; supplier = ()-&gt;new User();等同于：    Supplier&lt;User&gt; supplier = User::new;</code></pre><p><strong><code>注意:</code></strong><br>需要调用的构造器方法与函数式接口中抽象方法的参数列表保持一致。</p><h4 id="Lambda是怎么实现的？"><a href="#Lambda是怎么实现的？" class="headerlink" title="Lambda是怎么实现的？"></a>Lambda是怎么实现的？</h4><p>研究了半天Lambda怎么写，可是它的原理是什么？我们简单看个例子，看看真相到底是什么：</p><pre><code>public class StreamTest {    public static void main(String[] args) {        printString(&quot;hello lambda&quot;, (String s) -&gt; System.out.println(s));    }    public static void printString(String s, Print&lt;String&gt; print) {        print.print(s);    }}@FunctionalInterfaceinterface Print&lt;T&gt; {    public void print(T t);}</code></pre><p> 上面的代码自定义了一个函数式接口，定义一个静态方法然后用这个函数式接口来接收参数。编写完这个类以后，我们到终端界面javac进行编译，然后用javap（javap是jdk自带的反解析工具。它的作用就是根据class字节码文件，反解析出当前类对应的code区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等等信息。）进行解析，如下图：</p><ul><li>执行javap -p 命令 (  -p  -private             显示所有类和成员)<br><img src="https://user-gold-cdn.xitu.io/2019/7/16/16bf81c31491a04a?w=990&h=286&f=png&s=346959" alt><br>看上图发现在编译Lambda表达式生成了一个<code>lambda$main$0</code>静态方法，这个静态方法实现了Lambda表达式的逻辑，现在我们知道原来Lambda表达式被编译成了一个静态方法，那么这个静态方式是怎么调用的呢？我们继续进行</li><li>执行javap -v -p 命令 (  -v  -verbose             输出附加信息)</li></ul><pre><code>  public com.lxs.stream.StreamTest();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: return      LineNumberTable:        line 7: 0  public static void main(java.lang.String[]);    descriptor: ([Ljava/lang/String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=2, locals=1, args_size=1         0: ldc           #2                  // String hello lambda         2: invokedynamic #3,  0              // InvokeDynamic #0:print:()Lcom/lxs/stream/Print;         7: invokestatic  #4                  // Method printString:(Ljava/lang/String;Lcom/lxs/stream/Print;)V        10: return      LineNumberTable:        line 10: 0        line 12: 10  public static void printString(java.lang.String, com.lxs.stream.Print&lt;java.lang.String&gt;);    descriptor: (Ljava/lang/String;Lcom/lxs/stream/Print;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=2, locals=2, args_size=2         0: aload_1         1: aload_0         2: invokeinterface #5,  2            // InterfaceMethod com/lxs/stream/Print.print:(Ljava/lang/Object;)V         7: return      LineNumberTable:        line 15: 0        line 16: 7    Signature: #19                          // (Ljava/lang/String;Lcom/lxs/stream/Print&lt;Ljava/lang/String;&gt;;)V  private static void lambda$main$0(java.lang.String);    descriptor: (Ljava/lang/String;)V    flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC    Code:      stack=2, locals=1, args_size=1         0: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;         3: aload_0         4: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V         7: return      LineNumberTable:        line 10: 0}SourceFile: &quot;StreamTest.java&quot;InnerClasses:     public static final #58= #57 of #61; //Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandlesBootstrapMethods:  0: #27 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;    Method arguments:      #28 (Ljava/lang/Object;)V      #29 invokestatic com/lxs/stream/StreamTest.lambda$main$0:(Ljava/lang/String;)V      #30 (Ljava/lang/String;)V</code></pre><p>这里只贴出了一部分的字节码结构，由于常量池定义太长了，就没有粘贴。</p><pre><code>InnerClasses:     public static final #58= #57 of #61; //Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandlesBootstrapMethods:  0: #27 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;    Method arguments:      #28 (Ljava/lang/Object;)V      #29 invokestatic com/lxs/stream/StreamTest.lambda$main$0:(Ljava/lang/String;)V      #30 (Ljava/lang/String;)V</code></pre><p>通过这段字节码结构发现是要生成一个内部类，使用invokestatic调用了一个LambdaMetafactory.metafactory方法，并把<code>lambda$main$0</code>作为参数传了进去，我们来看metafactory 的方法里的实现代码：</p><pre><code>    public static CallSite metafactory(MethodHandles.Lookup caller,                                       String invokedName,                                       MethodType invokedType,                                       MethodType samMethodType,                                       MethodHandle implMethod,                                       MethodType instantiatedMethodType)            throws LambdaConversionException {        AbstractValidatingLambdaMetafactory mf;        mf = new InnerClassLambdaMetafactory(caller, invokedType,                                             invokedName, samMethodType,                                             implMethod, instantiatedMethodType,                                             false, EMPTY_CLASS_ARRAY, EMPTY_MT_ARRAY);        mf.validateMetafactoryArgs();        return mf.buildCallSite();    }</code></pre><p>在buildCallSite的函数中,是函数spinInnerClass 构建了这个内部类。也就是生成了一个StreamTest$$Lambda$1.class这样的内部类,这个类是在运行的时候构建的，并不会保存在磁盘中。</p><pre><code>    @Override    CallSite buildCallSite() throws LambdaConversionException {        final Class&lt;?&gt; innerClass = spinInnerClass();        以下省略。。。    }</code></pre><p>如果想看到这个构建的类，可以通过设置环境参数<br>System.setProperty(“jdk.internal.lambda.dumpProxyClasses”, “ . “);<br>会在你指定的路径 . 当前运行路径上生成这个内部类。我们看下一下生成的类长什么样<br><img src="https://user-gold-cdn.xitu.io/2019/7/16/16bf81c31b9be099?w=1772&h=286&f=png&s=297718" alt><br>从图中可以看出动态生成的内部类实现了我自定义的函数式接口，并且重写了函数式接口中的方法。</p><p>我们在javap -v -p StreamTest$$Lambda$1.class看下：</p><pre><code>{  private com.lxs.stream.StreamTest$$Lambda$1();    descriptor: ()V    flags: ACC_PRIVATE    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #10                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: return  public void print(java.lang.Object);    descriptor: (Ljava/lang/Object;)V    flags: ACC_PUBLIC    Code:      stack=1, locals=2, args_size=2         0: aload_1         1: checkcast     #15                 // class java/lang/String         4: invokestatic  #21                 // Method com/lxs/stream/StreamTest.lambda$main$0:(Ljava/lang/String;)V         7: return    RuntimeVisibleAnnotations:      0: #13()}</code></pre><p>发现在重写的parint方法中使用invokestatic指令调用了lambda$main$0方法。</p><p><strong>总结：</strong><br>这样实现了Lambda表达式，使用invokedynamic指令，运行时调用LambdaMetafactory.metafactory动态的生成内部类，实现了函数式接口，并在重写函数式接口中的方法，在方法内调用<code>lambda$main$0</code>，内部类里的调用方法块并不是动态生成的，只是在原class里已经编译生成了一个静态的方法，内部类只需要调用该静态方法。</p><blockquote><p>感谢大家的观看，希望多多关注哦。 如有错误，烦请指正。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Go学习笔记」1.初识Go</title>
      <link href="/2019/10/30/go-xue-xi-bi-ji-1-chu-shi-go/"/>
      <url>/2019/10/30/go-xue-xi-bi-ji-1-chu-shi-go/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>由于在公司广泛使用Docker的大环境下，突然对它的编程语言（Go）了解下。并且感觉现在Go语言的应用也是越来越广泛，很多互联网大厂都在使用，目前利用业余时间来学习下，主流还是Java，学明白以后可能考虑转哦🤡。如果你也感兴趣不如一起来学习。</p><h4 id="Go介绍"><a href="#Go介绍" class="headerlink" title="Go介绍"></a>Go介绍</h4><ul><li><p>简史</p><p>Go语言是Google于2009年正式发布的一款开源的静态编译型语言。Go语言最早于2007年Robert Griesemer(Java HotSpot虚拟机、V8引擎开发者之一)和Ken Thompson(贝尔实验室UNIX团队成员，C语言、UNIX和Plan9创始人之一)与Rob Pike三人在业余时间联合开发。（<code>老外就是吊</code>）时至今日Go语言已完成自举，社区生态斐然，包括大量拿的出手的杀手锏级项目（Moby、Docker、Kubernetes、Gogs、Grafana、Etcd）。</p></li><li><p>特性</p><ol><li>Go语言拥有自动垃圾回收功能，同时也允许开发人员干预回收操作。</li><li>Go语言有着更加丰富的内置类型，在错误处理方面语法更加精简高效。</li><li>Go语言函数支持多个返回值，而函数也是一种类型，可以作为参数传递。</li><li>Go语言对多核处理器编程进行了优化，可以从程序与结构方面来实现并发编程。</li><li>Go语言初次编译速度媲美C/C++,甚至二次编译的速度明显快于C/C++，同时又拥有接近于Python等解释型语言的简洁。</li></ol></li><li><p>命名规范</p><p>Go语言的项目命名一般采用 【域名+项目名】，例如：github.com/example,这样命名的目录一是可以分割项目，不容易重名，二是能够迅速找到原项目的地址，三是方便获取代码包。</p></li><li><p>代码强制格式化</p><p>Go语言有一个特色就是强制代码格式化，在你保存代码之后，可以使用go fmt工具格式化，当然即使没有手动格式化，在编译时，Go语言编译器也会自动格式化所有源代码，这种强制格式化的做法可以有效统一编码风格。</p></li></ul><h4 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h4><p>目前Go语言支持Linux、FreeBSD、Mac OS、和Windows平台，安装包可以从 <a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">https://golang.google.cn/dl/</a> 下载。</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/12/16dbe83fa456c748?w=1089&h=601&f=png&s=126174" alt></p><h4 id="基本命令及使用"><a href="#基本命令及使用" class="headerlink" title="基本命令及使用"></a>基本命令及使用</h4><ul><li><p>基本命令<br>安装Go语言环境后就可以使用go命令了，直接输入go help查看有哪些命令可用：</p><pre><code>$ go help  go是用于管理Go语言源代码的工具。  用法：      go command [arguments]  包含的命令如下：  - build: 编译源代码包和依赖。  - clean: 删除对象文件。  - doc: 显示Go包或程序实体的文档。  - env: 打印输出Go语言环境的变量信息。  - bug: bug提交程序。  - fix: 修复程序。  - fmt: 格式化源码包中代码。  - generate: 通过扫描Go源码中的go:generate注释来识别要运行的常规命令。  - get: 下载并安装指定的包与依赖。  - install: 编译并安装指定的包与依赖。  - list: 打印指定源码包信息。  - run: 编译并运行Go程序。  - test: 测试一个源码包。  - tool: 运行一个指定的tool。  - version: 打印输出Go环境版本。  - vet: 检查源码包中可能出现的错误。  使用&quot;go help [command]&quot;查看每一个命令的使用细节。</code></pre></li><li><p>目录结构</p><ol><li><p>GOROOT结构</p><p>$GOROOT 作为Go语言环境的根目录，放置了下面这些内容：</p></li></ol><pre><code>&amp; cd $GOROOT &amp;&amp; ls -l-rw-r--r--    1 root  wheel  55389  9 26 02:52 AUTHORS    # 所有参与Go语言开发的人员名单-rw-r--r--    1 root  wheel   1339  9 26 02:52 CONTRIBUTING.md    # 为Go语言贡献代码的说明-rw-r--r--    1 root  wheel  84339  9 26 02:52 CONTRIBUTORS   # 所有贡献者名单-rw-r--r--    1 root  wheel   1479  9 26 02:52 LICENSE    # Go语言的开源协议-rw-r--r--    1 root  wheel   1303  9 26 02:52 PATENTS    # Go语言专利说明-rw-r--r--    1 root  wheel   1607  9 26 02:52 README.md    # 说明文件-rw-r--r--    1 root  wheel    397  9 26 02:52 SECURITY.md-rw-r--r--    1 root  wheel      8  9 26 02:52 VERSION    # Go语言版本文件drwxr-xr-x   19 root  wheel    608  9 26 02:55 api  # Go语言API相关(变量、常量、函数)drwxr-xr-x    4 root  wheel    128  9 26 02:55 bin   # 用于存储标准命令执行文件，go、godoc、gofmt三件套drwxr-xr-x   50 root  wheel   1600  9 26 02:55 doc   # 存放标准库的文档-rw-r--r--    1 root  wheel   5686  9 26 02:52 favicon.ico  # Go语言的图标drwxr-xr-x    3 root  wheel     96  9 26 02:55 lib   # 存放一些特殊的库文件drwxr-xr-x   16 root  wheel    512  9 26 02:55 misc   # 辅助工具和说明drwxr-xr-x    6 root  wheel    192  9 26 02:55 pkg    # 存放Go语言标准库生成的文件-rw-r--r--    1 root  wheel     26  9 26 02:52 robots.txt    # 禁止搜索引擎索引本地启动的Go文档drwxr-xr-x   71 root  wheel   2272  9 26 02:55 src    # 存放GO语言自己的源代码drwxr-xr-x  327 root  wheel  10464  9 26 02:55 test   # 存放测试验证相关的文件</code></pre><ol start="2"><li><p>GOPATH结构</p><p>$GOPATH就是一个工作目录，我们开发GO语言程序就是在这里进行的，这个目录一般有三个文件夹：</p><pre><code>- bin: 存放go install生成的可执行文件前面把$GOPATH/bin路径加入PATH环境变量后就可以在全局任意位置使用这个文件夹内的执行文件。- pkg: 存放go编辑生成的文件。- src: 存放我们开发的Go项目的源代码，不用工程项目的代码已包名区分。</code></pre></li></ol></li></ul><h4 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h4><ul><li><p>Visual Studio Code</p><p>来自微软的开源编辑器Visual Studio Code的确是开发Go语言程序的好工具之一，庞大的生态系统使得它不仅仅是一个编辑器，它还拥有大部分Go语言开发过程中使用的工具链。</p></li><li><p>VIM-Go</p><p>VIM编辑器是大部分程序员的最爱之一，在VIM的生态中也有一款比较流行的GO语言开发插件—-VIM-GO，安装这个插件与安装其他VIM插件的方法一样。</p></li><li><p>Gogland</p><p>来自著名的Jetbrains公司开发的IDE（Goland）是一款专门为Go语言开发而设计的IDE。</p></li><li><p>LiteIDE</p><p>LiteIDE是一款专门为GO语言开发的跨平台轻量级集成开发环境，LiteIDE是开源的工具，代码托管在github上。</p></li></ul><h4 id="第一个Go程序"><a href="#第一个Go程序" class="headerlink" title="第一个Go程序"></a>第一个Go程序</h4><p>现在开始编写第一个程序了，创建一个组织目录，例如 code.local,然后建立一个项目名为hello-word,最终目录路径为$PATH/src/code.local/hello-word<br><img src="https://user-gold-cdn.xitu.io/2019/10/16/16dd0327863f47b1?w=1610&h=838&f=png&s=695373" alt><br>接来下使用vim 编辑一个main.go</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/16/16dd03ab2a011618?w=582&h=286&f=png&s=63707" alt><br>然后:wq保存，接来下可以直接使用go run命令运行程序。<br><img src="https://user-gold-cdn.xitu.io/2019/10/16/16dd03c1e1887a62?w=1216&h=284&f=png&s=163852" alt><br>到此我们就完成了第一个go程序。随着go语言越来越🔥，我对它也是很感兴趣，无奈没有太多的时间来学习，只能用周末来抽空看看，希望大家多多支持，如果你也对Go语言感兴趣，不妨点击下关注，一起学习。</p><blockquote><p>感谢大家的观看，希望多多关注哦。 如有错误，烦请指正。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> GO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
